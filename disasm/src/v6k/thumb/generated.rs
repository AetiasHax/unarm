#![cfg_attr(rustfmt, rustfmt_skip)]
#![allow(unused)]
#![allow(clippy::double_parens, clippy::unnecessary_cast)]
// Generated by unarm-generator. Do not edit!
use crate::{ParseFlags, args::*, parse::ParsedIns};
use super::Ins;
/// These are the mnemonics of each opcode. Some mnemonics are duplicated due to them having multiple formats.
static OPCODE_MNEMONICS: [&str; 76] = [
    "adcs",
    "adds",
    "adds",
    "adds",
    "add",
    "add",
    "add",
    "add",
    "add",
    "adr",
    "ands",
    "asrs",
    "asrs",
    "b",
    "b",
    "bics",
    "bkpt",
    "bl",
    "bl",
    "blx",
    "blx",
    "bx",
    "cmn",
    "cmp",
    "cmp",
    "cmp",
    "cps",
    "eors",
    "ldm",
    "ldr",
    "ldr",
    "ldr",
    "ldr",
    "ldrb",
    "ldrb",
    "ldrh",
    "ldrh",
    "ldrsb",
    "ldrsh",
    "lsls",
    "lsls",
    "lsrs",
    "lsrs",
    "movs",
    "movs",
    "mov",
    "muls",
    "mvns",
    "rsbs",
    "orrs",
    "pop",
    "push",
    "rev",
    "rev16",
    "revsh",
    "rors",
    "sbcs",
    "setend",
    "stm",
    "str",
    "str",
    "str",
    "strb",
    "strb",
    "strh",
    "strh",
    "subs",
    "subs",
    "subs",
    "sub",
    "svc",
    "sxtb",
    "sxth",
    "tst",
    "uxtb",
    "uxth",
];
#[derive(Clone, Copy, Debug, Default, PartialEq, Eq)]
#[repr(u8)]
#[non_exhaustive]
pub enum Opcode {
    /// Illegal or unknown
    #[default]
    Illegal = u8::MAX,
    /// ADCS: Add with Carry
    Adcs = 0,
    /// ADDS: Add 3-bit immediate
    Adds3 = 1,
    /// ADDS: Add 8-bit immediate
    Adds8 = 2,
    /// ADDS: Add register
    AddsR = 3,
    /// ADD: Add high register
    AddHr = 4,
    /// ADD: Add SP-relative address
    AddSp = 5,
    /// ADD: Add 7-bit immediate multiple of 4 to SP
    AddSp7 = 6,
    /// ADD: Add SP to register
    AddRegSp = 7,
    /// ADD: Add register to SP
    AddSpReg = 8,
    /// ADR: Add PC-relative address
    Adr = 9,
    /// ANDS: Bitwise AND
    Ands = 10,
    /// ASRS: Arithmetic Shift Right by 5-bit immediate
    AsrsI = 11,
    /// ASRS: Arithmetic Shift Right by register
    AsrsR = 12,
    /// B: Branch
    B = 13,
    /// B: Branch (unconditional, long)
    BLong = 14,
    /// BICS: Bit Clear
    Bics = 15,
    /// BKPT: Breakpoint
    Bkpt = 16,
    /// BL: Branch and Link (high part)
    BlH = 17,
    /// BL: Branch and Link (low part)
    Bl = 18,
    /// BLX: Branch and Link and Exchange to ARM (low part, immediate target)
    BlxI = 19,
    /// BLX: Branch and Link and Exchange to ARM (register target)
    BlxR = 20,
    /// BX: Branch and Exchange
    BxR = 21,
    /// CMN: Compare Negative
    Cmn = 22,
    /// CMP: Compare with immediate
    CmpI = 23,
    /// CMP: Compare with register
    CmpR = 24,
    /// CMP: Compare with high register
    CmpHr = 25,
    /// CPS: Change Processor State
    Cps = 26,
    /// EORS: Exclusive OR
    Eors = 27,
    /// LDM: Load Multiple
    Ldm = 28,
    /// LDR: Load Register with immediate offset
    LdrI = 29,
    /// LDR: Load Register with register offset
    LdrR = 30,
    /// LDR: Load Register with PC-relative address
    LdrPc = 31,
    /// LDR: Load Register with SP-relative address
    LdrSp = 32,
    /// LDRB: Load Register Byte with immediate offset
    LdrbI = 33,
    /// LDRB: Load Register Byte with register offset
    LdrbR = 34,
    /// LDRH: Load Register Halfword with immediate offset
    LdrhI = 35,
    /// LDRH: Load Register Halfword with register offset
    LdrhR = 36,
    /// LDRSB: Load Register Signed Byte
    Ldrsb = 37,
    /// LDRSH: Load Register Signed Halfword
    Ldrsh = 38,
    /// LSLS: Logical Shift Left by 5-bit immediate
    LslsI = 39,
    /// LSLS: Logical Shift Left by register
    LslsR = 40,
    /// LSRS: Logical Shift Right by 5-bit immediate
    LsrsI = 41,
    /// LSRS: Logical Shift Right by register
    LsrsR = 42,
    /// MOVS: Move immediate
    MovsI = 43,
    /// MOVS: Move register
    MovsR = 44,
    /// MOV: Move high register
    MovHr = 45,
    /// MULS: Multiply
    Muls = 46,
    /// MVNS: Move Negative
    Mvns = 47,
    /// RSBS: Negate
    Rsbs = 48,
    /// ORRS: Bitwise OR
    Orrs = 49,
    /// POP: Pop multiple registers
    Pop = 50,
    /// PUSH: Push multiple registers
    Push = 51,
    /// REV: Byte-Reverse Word
    Rev = 52,
    /// REV16: Byte-Reverse Packed Halfword
    Rev16 = 53,
    /// REVSH: Byte-Reverse Signed Halfword
    Revsh = 54,
    /// RORS: Rotate Right
    Rors = 55,
    /// SBCS: Subtract with Carry
    Sbcs = 56,
    /// SETEND: Set Endian
    Setend = 57,
    /// STM: Store Multiple Increment After
    Stm = 58,
    /// STR: Store Register with immediate offset
    StrI = 59,
    /// STR: Store Register with register offset
    StrR = 60,
    /// STR: Store Register with SP-relative address
    StrSp = 61,
    /// STRB: Store Register Byte with immediate offset
    StrbI = 62,
    /// STRB: Store Register Byte with register offset
    StrbR = 63,
    /// STRH: Store Register Halfword with immediate offset
    StrhI = 64,
    /// STRH: Store Register Halfword with register offset
    StrhR = 65,
    /// SUBS: Subtract 3-bit immediate
    Subs3 = 66,
    /// SUBS: Subtract 8-bit immediate
    Subs8 = 67,
    /// SUBS: Subtract register
    SubsR = 68,
    /// SUB: Subtract 7-bit immediate multiple of 4 from SP
    SubSp7 = 69,
    /// SVC: Supervisor Call
    Svc = 70,
    /// SXTB: Sign Extend Byte to 32 bits
    Sxtb = 71,
    /// SXTH: Sign Extend Halfword to 32 bits
    Sxth = 72,
    /// TST: Test
    Tst = 73,
    /// UXTB: Zero Extend Byte to 32 bits
    Uxtb = 74,
    /// UXTH: Zero Extend Halfword to 32 bits
    Uxth = 75,
}
impl Opcode {
    #[inline]
    pub fn find(code: u32) -> Self {
        if (code & 0x00001000) == 0x00000000 {
            if (code & 0x00000400) == 0x00000400 {
                if (code & 0x00000800) == 0x00000000 {
                    if (code & 0x00000100) == 0x00000100 {
                        if (code & 0x00002000) == 0x00000000 {
                            if (code & 0x00000200) == 0x00000000 {
                                if (code & 0x00004000) == 0x00000000 {
                                    if (code & 0x00008000) == 0x00000000 {
                                        if (code & 0x0000f800) == 0x00000000 {
                                            return Opcode::LslsI;
                                        }
                                    } else if (code & 0x0000f800) == 0x00008000 {
                                        return Opcode::StrhI;
                                    }
                                } else if (code & 0x00008000) == 0x00000000 {
                                    if (code & 0x0000ff00) == 0x00004500 {
                                        return Opcode::CmpHr;
                                    }
                                } else if (code & 0x0000f800) == 0x0000c000 {
                                    return Opcode::Stm;
                                }
                            } else if (code & 0x00004000) == 0x00000000 {
                                if (code & 0x00008000) == 0x00000000 {
                                    if (code & 0x0000f800) == 0x00000000 {
                                        return Opcode::LslsI;
                                    }
                                } else if (code & 0x0000f800) == 0x00008000 {
                                    return Opcode::StrhI;
                                }
                            } else if (code & 0x00008000) == 0x00008000 {
                                if (code & 0x0000f800) == 0x0000c000 {
                                    return Opcode::Stm;
                                }
                            } else if (code & 0x00000080) == 0x00000000 {
                                if (code & 0x0000ff87) == 0x00004700 {
                                    return Opcode::BxR;
                                }
                            } else if (code & 0x0000ff87) == 0x00004780 {
                                return Opcode::BlxR;
                            }
                        } else if (code & 0x00004000) == 0x00000000 {
                            if (code & 0x00008000) == 0x00000000 {
                                if (code & 0x0000f800) == 0x00002000 {
                                    return Opcode::MovsI;
                                }
                            } else if (code & 0x0000f800) == 0x0000a000 {
                                return Opcode::Adr;
                            }
                        } else if (code & 0x00008000) == 0x00000000 {
                            if (code & 0x0000f800) == 0x00006000 {
                                return Opcode::StrI;
                            }
                        } else if (code & 0x0000f800) == 0x0000e000 {
                            return Opcode::BLong;
                        }
                    } else if (code & 0x00002000) == 0x00000000 {
                        if (code & 0x00000200) == 0x00000200 {
                            if (code & 0x00004000) == 0x00000000 {
                                if (code & 0x00008000) == 0x00000000 {
                                    if (code & 0x0000f800) == 0x00000000 {
                                        return Opcode::LslsI;
                                    }
                                } else if (code & 0x0000f800) == 0x00008000 {
                                    return Opcode::StrhI;
                                }
                            } else if (code & 0x00008000) == 0x00000000 {
                                if (code & 0x0000ff00) == 0x00004600 {
                                    return Opcode::MovHr;
                                }
                            } else if (code & 0x0000f800) == 0x0000c000 {
                                return Opcode::Stm;
                            }
                        } else if (code & 0x00004000) == 0x00004000 {
                            if (code & 0x00008000) == 0x00000000 {
                                if (code & 0x0000ff78) == 0x00004468 {
                                    return Opcode::AddRegSp;
                                } else if (code & 0x0000ff87) == 0x00004485 {
                                    return Opcode::AddSpReg;
                                } else if (code & 0x0000ff00) == 0x00004400 {
                                    return Opcode::AddHr;
                                }
                            } else if (code & 0x0000f800) == 0x0000c000 {
                                return Opcode::Stm;
                            }
                        } else if (code & 0x00008000) == 0x00000000 {
                            if (code & 0x0000f800) == 0x00000000 {
                                return Opcode::LslsI;
                            }
                        } else if (code & 0x0000f800) == 0x00008000 {
                            return Opcode::StrhI;
                        }
                    } else if (code & 0x00004000) == 0x00000000 {
                        if (code & 0x00008000) == 0x00000000 {
                            if (code & 0x0000f800) == 0x00002000 {
                                return Opcode::MovsI;
                            }
                        } else if (code & 0x0000f800) == 0x0000a000 {
                            return Opcode::Adr;
                        }
                    } else if (code & 0x00008000) == 0x00000000 {
                        if (code & 0x0000f800) == 0x00006000 {
                            return Opcode::StrI;
                        }
                    } else if (code & 0x0000f800) == 0x0000e000 {
                        return Opcode::BLong;
                    }
                } else if (code & 0x00002000) == 0x00000000 {
                    if (code & 0x00004000) == 0x00000000 {
                        if (code & 0x00008000) == 0x00000000 {
                            if (code & 0x0000f800) == 0x00000800 {
                                return Opcode::LsrsI;
                            }
                        } else if (code & 0x0000f800) == 0x00008800 {
                            return Opcode::LdrhI;
                        }
                    } else if (code & 0x00008000) == 0x00000000 {
                        if (code & 0x0000f800) == 0x00004800 {
                            return Opcode::LdrPc;
                        }
                    } else if (code & 0x0000f800) == 0x0000c800 {
                        return Opcode::Ldm;
                    }
                } else if (code & 0x00004000) == 0x00000000 {
                    if (code & 0x00008000) == 0x00000000 {
                        if (code & 0x0000f800) == 0x00002800 {
                            return Opcode::CmpI;
                        }
                    } else if (code & 0x0000f800) == 0x0000a800 {
                        return Opcode::AddSp;
                    }
                } else if (code & 0x00008000) == 0x00000000 {
                    if (code & 0x0000f800) == 0x00006800 {
                        return Opcode::LdrI;
                    }
                } else if (code & 0x0000f800) == 0x0000e800 {
                    return Opcode::BlxI;
                }
            } else if (code & 0x00000040) == 0x00000040 {
                if (code & 0x00000800) == 0x00000000 {
                    if (code & 0x00000080) == 0x00000000 {
                        if (code & 0x00002000) == 0x00000000 {
                            if (code & 0x00000100) == 0x00000000 {
                                if (code & 0x00004000) == 0x00000000 {
                                    if (code & 0x00008000) == 0x00000000 {
                                        if (code & 0x0000f800) == 0x00000000 {
                                            return Opcode::LslsI;
                                        }
                                    } else if (code & 0x0000f800) == 0x00008000 {
                                        return Opcode::StrhI;
                                    }
                                } else if (code & 0x00008000) == 0x00008000 {
                                    if (code & 0x0000f800) == 0x0000c000 {
                                        return Opcode::Stm;
                                    }
                                } else if (code & 0x00000200) == 0x00000000 {
                                    if (code & 0x0000ffc0) == 0x00004040 {
                                        return Opcode::Eors;
                                    }
                                } else if (code & 0x0000ffc0) == 0x00004240 {
                                    return Opcode::Rsbs;
                                }
                            } else if (code & 0x00004000) == 0x00000000 {
                                if (code & 0x00008000) == 0x00000000 {
                                    if (code & 0x0000f800) == 0x00000000 {
                                        return Opcode::LslsI;
                                    }
                                } else if (code & 0x0000f800) == 0x00008000 {
                                    return Opcode::StrhI;
                                }
                            } else if (code & 0x00008000) == 0x00008000 {
                                if (code & 0x0000f800) == 0x0000c000 {
                                    return Opcode::Stm;
                                }
                            } else if (code & 0x00000200) == 0x00000000 {
                                if (code & 0x0000ffc0) == 0x00004140 {
                                    return Opcode::Adcs;
                                }
                            } else if (code & 0x0000ffc0) == 0x00004340 {
                                return Opcode::Muls;
                            }
                        } else if (code & 0x00004000) == 0x00000000 {
                            if (code & 0x00008000) == 0x00000000 {
                                if (code & 0x0000f800) == 0x00002000 {
                                    return Opcode::MovsI;
                                }
                            } else if (code & 0x0000f800) == 0x0000a000 {
                                return Opcode::Adr;
                            }
                        } else if (code & 0x00008000) == 0x00000000 {
                            if (code & 0x0000f800) == 0x00006000 {
                                return Opcode::StrI;
                            }
                        } else if (code & 0x0000f800) == 0x0000e000 {
                            return Opcode::BLong;
                        }
                    } else if (code & 0x00002000) == 0x00000000 {
                        if (code & 0x00000100) == 0x00000000 {
                            if (code & 0x00004000) == 0x00000000 {
                                if (code & 0x00008000) == 0x00000000 {
                                    if (code & 0x0000f800) == 0x00000000 {
                                        return Opcode::LslsI;
                                    }
                                } else if (code & 0x0000f800) == 0x00008000 {
                                    return Opcode::StrhI;
                                }
                            } else if (code & 0x00008000) == 0x00008000 {
                                if (code & 0x0000f800) == 0x0000c000 {
                                    return Opcode::Stm;
                                }
                            } else if (code & 0x00000200) == 0x00000000 {
                                if (code & 0x0000ffc0) == 0x000040c0 {
                                    return Opcode::LsrsR;
                                }
                            } else if (code & 0x0000ffc0) == 0x000042c0 {
                                return Opcode::Cmn;
                            }
                        } else if (code & 0x00004000) == 0x00000000 {
                            if (code & 0x00008000) == 0x00000000 {
                                if (code & 0x0000f800) == 0x00000000 {
                                    return Opcode::LslsI;
                                }
                            } else if (code & 0x0000f800) == 0x00008000 {
                                return Opcode::StrhI;
                            }
                        } else if (code & 0x00008000) == 0x00008000 {
                            if (code & 0x0000f800) == 0x0000c000 {
                                return Opcode::Stm;
                            }
                        } else if (code & 0x00000200) == 0x00000000 {
                            if (code & 0x0000ffc0) == 0x000041c0 {
                                return Opcode::Rors;
                            }
                        } else if (code & 0x0000ffc0) == 0x000043c0 {
                            return Opcode::Mvns;
                        }
                    } else if (code & 0x00004000) == 0x00000000 {
                        if (code & 0x00008000) == 0x00000000 {
                            if (code & 0x0000f800) == 0x00002000 {
                                return Opcode::MovsI;
                            }
                        } else if (code & 0x0000f800) == 0x0000a000 {
                            return Opcode::Adr;
                        }
                    } else if (code & 0x00008000) == 0x00000000 {
                        if (code & 0x0000f800) == 0x00006000 {
                            return Opcode::StrI;
                        }
                    } else if (code & 0x0000f800) == 0x0000e000 {
                        return Opcode::BLong;
                    }
                } else if (code & 0x00002000) == 0x00000000 {
                    if (code & 0x00004000) == 0x00000000 {
                        if (code & 0x00008000) == 0x00000000 {
                            if (code & 0x0000f800) == 0x00000800 {
                                return Opcode::LsrsI;
                            }
                        } else if (code & 0x0000f800) == 0x00008800 {
                            return Opcode::LdrhI;
                        }
                    } else if (code & 0x00008000) == 0x00000000 {
                        if (code & 0x0000f800) == 0x00004800 {
                            return Opcode::LdrPc;
                        }
                    } else if (code & 0x0000f800) == 0x0000c800 {
                        return Opcode::Ldm;
                    }
                } else if (code & 0x00004000) == 0x00000000 {
                    if (code & 0x00008000) == 0x00000000 {
                        if (code & 0x0000f800) == 0x00002800 {
                            return Opcode::CmpI;
                        }
                    } else if (code & 0x0000f800) == 0x0000a800 {
                        return Opcode::AddSp;
                    }
                } else if (code & 0x00008000) == 0x00000000 {
                    if (code & 0x0000f800) == 0x00006800 {
                        return Opcode::LdrI;
                    }
                } else if (code & 0x0000f800) == 0x0000e800 {
                    return Opcode::BlxI;
                }
            } else if (code & 0x00004000) == 0x00004000 {
                if (code & 0x00000080) == 0x00000000 {
                    if (code & 0x00000800) == 0x00000000 {
                        if (code & 0x00000100) == 0x00000000 {
                            if (code & 0x00002000) == 0x00002000 {
                                if (code & 0x00008000) == 0x00000000 {
                                    if (code & 0x0000f800) == 0x00006000 {
                                        return Opcode::StrI;
                                    }
                                } else if (code & 0x0000f800) == 0x0000e000 {
                                    return Opcode::BLong;
                                }
                            } else if (code & 0x00008000) == 0x00008000 {
                                if (code & 0x0000f800) == 0x0000c000 {
                                    return Opcode::Stm;
                                }
                            } else if (code & 0x00000200) == 0x00000000 {
                                if (code & 0x0000ffc0) == 0x00004000 {
                                    return Opcode::Ands;
                                }
                            } else if (code & 0x0000ffc0) == 0x00004200 {
                                return Opcode::Tst;
                            }
                        } else if (code & 0x00002000) == 0x00002000 {
                            if (code & 0x00008000) == 0x00000000 {
                                if (code & 0x0000f800) == 0x00006000 {
                                    return Opcode::StrI;
                                }
                            } else if (code & 0x0000f800) == 0x0000e000 {
                                return Opcode::BLong;
                            }
                        } else if (code & 0x00008000) == 0x00008000 {
                            if (code & 0x0000f800) == 0x0000c000 {
                                return Opcode::Stm;
                            }
                        } else if (code & 0x00000200) == 0x00000000 {
                            if (code & 0x0000ffc0) == 0x00004100 {
                                return Opcode::AsrsR;
                            }
                        } else if (code & 0x0000ffc0) == 0x00004300 {
                            return Opcode::Orrs;
                        }
                    } else if (code & 0x00002000) == 0x00000000 {
                        if (code & 0x00008000) == 0x00000000 {
                            if (code & 0x0000f800) == 0x00004800 {
                                return Opcode::LdrPc;
                            }
                        } else if (code & 0x0000f800) == 0x0000c800 {
                            return Opcode::Ldm;
                        }
                    } else if (code & 0x00008000) == 0x00000000 {
                        if (code & 0x0000f800) == 0x00006800 {
                            return Opcode::LdrI;
                        }
                    } else if (code & 0x0000f800) == 0x0000e800 {
                        return Opcode::BlxI;
                    }
                } else if (code & 0x00000800) == 0x00000000 {
                    if (code & 0x00000100) == 0x00000000 {
                        if (code & 0x00002000) == 0x00002000 {
                            if (code & 0x00008000) == 0x00000000 {
                                if (code & 0x0000f800) == 0x00006000 {
                                    return Opcode::StrI;
                                }
                            } else if (code & 0x0000f800) == 0x0000e000 {
                                return Opcode::BLong;
                            }
                        } else if (code & 0x00008000) == 0x00008000 {
                            if (code & 0x0000f800) == 0x0000c000 {
                                return Opcode::Stm;
                            }
                        } else if (code & 0x00000200) == 0x00000000 {
                            if (code & 0x0000ffc0) == 0x00004080 {
                                return Opcode::LslsR;
                            }
                        } else if (code & 0x0000ffc0) == 0x00004280 {
                            return Opcode::CmpR;
                        }
                    } else if (code & 0x00002000) == 0x00002000 {
                        if (code & 0x00008000) == 0x00000000 {
                            if (code & 0x0000f800) == 0x00006000 {
                                return Opcode::StrI;
                            }
                        } else if (code & 0x0000f800) == 0x0000e000 {
                            return Opcode::BLong;
                        }
                    } else if (code & 0x00008000) == 0x00008000 {
                        if (code & 0x0000f800) == 0x0000c000 {
                            return Opcode::Stm;
                        }
                    } else if (code & 0x00000200) == 0x00000000 {
                        if (code & 0x0000ffc0) == 0x00004180 {
                            return Opcode::Sbcs;
                        }
                    } else if (code & 0x0000ffc0) == 0x00004380 {
                        return Opcode::Bics;
                    }
                } else if (code & 0x00002000) == 0x00000000 {
                    if (code & 0x00008000) == 0x00000000 {
                        if (code & 0x0000f800) == 0x00004800 {
                            return Opcode::LdrPc;
                        }
                    } else if (code & 0x0000f800) == 0x0000c800 {
                        return Opcode::Ldm;
                    }
                } else if (code & 0x00008000) == 0x00000000 {
                    if (code & 0x0000f800) == 0x00006800 {
                        return Opcode::LdrI;
                    }
                } else if (code & 0x0000f800) == 0x0000e800 {
                    return Opcode::BlxI;
                }
            } else if (code & 0x00000800) == 0x00000800 {
                if (code & 0x00002000) == 0x00000000 {
                    if (code & 0x00008000) == 0x00000000 {
                        if (code & 0x0000f800) == 0x00000800 {
                            return Opcode::LsrsI;
                        }
                    } else if (code & 0x0000f800) == 0x00008800 {
                        return Opcode::LdrhI;
                    }
                } else if (code & 0x00008000) == 0x00000000 {
                    if (code & 0x0000f800) == 0x00002800 {
                        return Opcode::CmpI;
                    }
                } else if (code & 0x0000f800) == 0x0000a800 {
                    return Opcode::AddSp;
                }
            } else if (code & 0x00002000) == 0x00002000 {
                if (code & 0x00008000) == 0x00000000 {
                    if (code & 0x0000f800) == 0x00002000 {
                        return Opcode::MovsI;
                    }
                } else if (code & 0x0000f800) == 0x0000a000 {
                    return Opcode::Adr;
                }
            } else if (code & 0x00008000) == 0x00008000 {
                if (code & 0x0000f800) == 0x00008000 {
                    return Opcode::StrhI;
                }
            } else if (code & 0x0000ffc0) == 0x00000000 {
                return Opcode::MovsR;
            } else if (code & 0x0000f800) == 0x00000000 {
                return Opcode::LslsI;
            }
        } else if (code & 0x00002000) == 0x00000000 {
            if (code & 0x00000200) == 0x00000000 {
                if (code & 0x00000800) == 0x00000000 {
                    if (code & 0x00004000) == 0x00000000 {
                        if (code & 0x00008000) == 0x00000000 {
                            if (code & 0x0000f800) == 0x00001000 {
                                return Opcode::AsrsI;
                            }
                        } else if (code & 0x0000f800) == 0x00009000 {
                            return Opcode::StrSp;
                        }
                    } else if (code & 0x00008000) == 0x00008000 {
                        if (code & 0x0000f000) == 0x0000d000 {
                            return Opcode::B;
                        }
                    } else if (code & 0x00000400) == 0x00000000 {
                        if (code & 0x0000fe00) == 0x00005000 {
                            return Opcode::StrR;
                        }
                    } else if (code & 0x0000fe00) == 0x00005400 {
                        return Opcode::StrbR;
                    }
                } else if (code & 0x00004000) == 0x00000000 {
                    if (code & 0x00008000) == 0x00008000 {
                        if (code & 0x0000f800) == 0x00009800 {
                            return Opcode::LdrSp;
                        }
                    } else if (code & 0x00000400) == 0x00000000 {
                        if (code & 0x0000fe00) == 0x00001800 {
                            return Opcode::AddsR;
                        }
                    } else if (code & 0x0000fe00) == 0x00001c00 {
                        return Opcode::Adds3;
                    }
                } else if (code & 0x00008000) == 0x00008000 {
                    if (code & 0x0000f000) == 0x0000d000 {
                        return Opcode::B;
                    }
                } else if (code & 0x00000400) == 0x00000000 {
                    if (code & 0x0000fe00) == 0x00005800 {
                        return Opcode::LdrR;
                    }
                } else if (code & 0x0000fe00) == 0x00005c00 {
                    return Opcode::LdrbR;
                }
            } else if (code & 0x00000400) == 0x00000000 {
                if (code & 0x00004000) == 0x00004000 {
                    if (code & 0x00008000) == 0x00008000 {
                        if (code & 0x0000f000) == 0x0000d000 {
                            return Opcode::B;
                        }
                    } else if (code & 0x00000800) == 0x00000000 {
                        if (code & 0x0000fe00) == 0x00005200 {
                            return Opcode::StrhR;
                        }
                    } else if (code & 0x0000fe00) == 0x00005a00 {
                        return Opcode::LdrhR;
                    }
                } else if (code & 0x00000800) == 0x00000000 {
                    if (code & 0x00008000) == 0x00000000 {
                        if (code & 0x0000f800) == 0x00001000 {
                            return Opcode::AsrsI;
                        }
                    } else if (code & 0x0000f800) == 0x00009000 {
                        return Opcode::StrSp;
                    }
                } else if (code & 0x00008000) == 0x00000000 {
                    if (code & 0x0000fe00) == 0x00001a00 {
                        return Opcode::SubsR;
                    }
                } else if (code & 0x0000f800) == 0x00009800 {
                    return Opcode::LdrSp;
                }
            } else if (code & 0x00000800) == 0x00000000 {
                if (code & 0x00004000) == 0x00000000 {
                    if (code & 0x00008000) == 0x00000000 {
                        if (code & 0x0000f800) == 0x00001000 {
                            return Opcode::AsrsI;
                        }
                    } else if (code & 0x0000f800) == 0x00009000 {
                        return Opcode::StrSp;
                    }
                } else if (code & 0x00008000) == 0x00000000 {
                    if (code & 0x0000fe00) == 0x00005600 {
                        return Opcode::Ldrsb;
                    }
                } else if (code & 0x0000f000) == 0x0000d000 {
                    return Opcode::B;
                }
            } else if (code & 0x00004000) == 0x00004000 {
                if (code & 0x00000100) == 0x00000000 {
                    if (code & 0x00008000) == 0x00000000 {
                        if (code & 0x0000fe00) == 0x00005e00 {
                            return Opcode::Ldrsh;
                        }
                    } else if (code & 0x0000ff00) == 0x0000de00 {
                        return Opcode::Bkpt;
                    } else if (code & 0x0000f000) == 0x0000d000 {
                        return Opcode::B;
                    }
                } else if (code & 0x00008000) == 0x00000000 {
                    if (code & 0x0000fe00) == 0x00005e00 {
                        return Opcode::Ldrsh;
                    }
                } else if (code & 0x0000ff00) == 0x0000df00 {
                    return Opcode::Svc;
                } else if (code & 0x0000f000) == 0x0000d000 {
                    return Opcode::B;
                }
            } else if (code & 0x00008000) == 0x00000000 {
                if (code & 0x0000fe00) == 0x00001e00 {
                    return Opcode::Subs3;
                }
            } else if (code & 0x0000f800) == 0x00009800 {
                return Opcode::LdrSp;
            }
        } else if (code & 0x00000200) == 0x00000000 {
            if (code & 0x00000800) == 0x00000000 {
                if (code & 0x00000400) == 0x00000400 {
                    if (code & 0x00004000) == 0x00000000 {
                        if (code & 0x00008000) == 0x00000000 {
                            if (code & 0x0000f800) == 0x00003000 {
                                return Opcode::Adds8;
                            }
                        } else if (code & 0x0000fe00) == 0x0000b400 {
                            return Opcode::Push;
                        }
                    } else if (code & 0x00008000) == 0x00000000 {
                        if (code & 0x0000f800) == 0x00007000 {
                            return Opcode::StrbI;
                        }
                    } else if (code & 0x0000f800) == 0x0000f000 {
                        return Opcode::BlH;
                    }
                } else if (code & 0x00004000) == 0x00004000 {
                    if (code & 0x00008000) == 0x00000000 {
                        if (code & 0x0000f800) == 0x00007000 {
                            return Opcode::StrbI;
                        }
                    } else if (code & 0x0000f800) == 0x0000f000 {
                        return Opcode::BlH;
                    }
                } else if (code & 0x00008000) == 0x00000000 {
                    if (code & 0x0000f800) == 0x00003000 {
                        return Opcode::Adds8;
                    }
                } else if (code & 0x00000080) == 0x00000000 {
                    if (code & 0x0000ff80) == 0x0000b000 {
                        return Opcode::AddSp7;
                    }
                } else if (code & 0x0000ff80) == 0x0000b080 {
                    return Opcode::SubSp7;
                }
            } else if (code & 0x00004000) == 0x00000000 {
                if (code & 0x00008000) == 0x00000000 {
                    if (code & 0x0000f800) == 0x00003800 {
                        return Opcode::Subs8;
                    }
                } else if (code & 0x0000fe00) == 0x0000bc00 {
                    return Opcode::Pop;
                }
            } else if (code & 0x00008000) == 0x00000000 {
                if (code & 0x0000f800) == 0x00007800 {
                    return Opcode::LdrbI;
                }
            } else if (code & 0x0000f800) == 0x0000f800 {
                return Opcode::Bl;
            }
        } else if (code & 0x00000400) == 0x00000400 {
            if (code & 0x00004000) == 0x00000000 {
                if (code & 0x00008000) == 0x00000000 {
                    if (code & 0x00000800) == 0x00000000 {
                        if (code & 0x0000f800) == 0x00003000 {
                            return Opcode::Adds8;
                        }
                    } else if (code & 0x0000f800) == 0x00003800 {
                        return Opcode::Subs8;
                    }
                } else if (code & 0x00000020) == 0x00000000 {
                    if (code & 0x0000fff7) == 0x0000b650 {
                        return Opcode::Setend;
                    }
                } else if (code & 0x0000ffe8) == 0x0000b660 {
                    return Opcode::Cps;
                }
            } else if (code & 0x00000800) == 0x00000000 {
                if (code & 0x00008000) == 0x00000000 {
                    if (code & 0x0000f800) == 0x00007000 {
                        return Opcode::StrbI;
                    }
                } else if (code & 0x0000f800) == 0x0000f000 {
                    return Opcode::BlH;
                }
            } else if (code & 0x00008000) == 0x00000000 {
                if (code & 0x0000f800) == 0x00007800 {
                    return Opcode::LdrbI;
                }
            } else if (code & 0x0000f800) == 0x0000f800 {
                return Opcode::Bl;
            }
        } else if (code & 0x00000800) == 0x00000800 {
            if (code & 0x00000040) == 0x00000000 {
                if (code & 0x00004000) == 0x00000000 {
                    if (code & 0x00008000) == 0x00000000 {
                        if (code & 0x0000f800) == 0x00003800 {
                            return Opcode::Subs8;
                        }
                    } else if (code & 0x0000ffc0) == 0x0000ba00 {
                        return Opcode::Rev;
                    }
                } else if (code & 0x00008000) == 0x00000000 {
                    if (code & 0x0000f800) == 0x00007800 {
                        return Opcode::LdrbI;
                    }
                } else if (code & 0x0000f800) == 0x0000f800 {
                    return Opcode::Bl;
                }
            } else if (code & 0x00004000) == 0x00004000 {
                if (code & 0x00008000) == 0x00000000 {
                    if (code & 0x0000f800) == 0x00007800 {
                        return Opcode::LdrbI;
                    }
                } else if (code & 0x0000f800) == 0x0000f800 {
                    return Opcode::Bl;
                }
            } else if (code & 0x00008000) == 0x00000000 {
                if (code & 0x0000f800) == 0x00003800 {
                    return Opcode::Subs8;
                }
            } else if (code & 0x00000080) == 0x00000000 {
                if (code & 0x0000ffc0) == 0x0000ba40 {
                    return Opcode::Rev16;
                }
            } else if (code & 0x0000ffc0) == 0x0000bac0 {
                return Opcode::Revsh;
            }
        } else if (code & 0x00000040) == 0x00000000 {
            if (code & 0x00004000) == 0x00004000 {
                if (code & 0x00008000) == 0x00000000 {
                    if (code & 0x0000f800) == 0x00007000 {
                        return Opcode::StrbI;
                    }
                } else if (code & 0x0000f800) == 0x0000f000 {
                    return Opcode::BlH;
                }
            } else if (code & 0x00008000) == 0x00000000 {
                if (code & 0x0000f800) == 0x00003000 {
                    return Opcode::Adds8;
                }
            } else if (code & 0x00000080) == 0x00000000 {
                if (code & 0x0000ffc0) == 0x0000b200 {
                    return Opcode::Sxth;
                }
            } else if (code & 0x0000ffc0) == 0x0000b280 {
                return Opcode::Uxth;
            }
        } else if (code & 0x00004000) == 0x00004000 {
            if (code & 0x00008000) == 0x00000000 {
                if (code & 0x0000f800) == 0x00007000 {
                    return Opcode::StrbI;
                }
            } else if (code & 0x0000f800) == 0x0000f000 {
                return Opcode::BlH;
            }
        } else if (code & 0x00008000) == 0x00000000 {
            if (code & 0x0000f800) == 0x00003000 {
                return Opcode::Adds8;
            }
        } else if (code & 0x00000080) == 0x00000000 {
            if (code & 0x0000ffc0) == 0x0000b240 {
                return Opcode::Sxtb;
            }
        } else if (code & 0x0000ffc0) == 0x0000b2c0 {
            return Opcode::Uxtb;
        }
        Opcode::Illegal
    }
    pub fn mnemonic(self) -> &'static str {
        OPCODE_MNEMONICS[self as usize]
    }
    pub fn count() -> usize {
        76
    }
}
impl Ins {
    /// Rd_0: Destination register
    #[inline(always)]
    pub fn field_rd_0(&self) -> Reg {
        Reg {
            deref: false,
            reg: Register::parse((self.code & 0x00000007)),
            writeback: false,
        }
    }
    /// Rd_8: Destination register
    #[inline(always)]
    pub fn field_rd_8(&self) -> Reg {
        Reg {
            deref: false,
            reg: Register::parse(((self.code >> 8) & 0x00000007)),
            writeback: false,
        }
    }
    /// Rd_H1: Destination register
    #[inline(always)]
    pub fn field_rd_h1(&self) -> Reg {
        Reg {
            deref: false,
            reg: Register::parse(
                (self.code & 0x00000007) | ((self.code >> 7) & 0x00000001) << 3,
            ),
            writeback: false,
        }
    }
    /// Rn_0: First source operand register
    #[inline(always)]
    pub fn field_rn_0(&self) -> Reg {
        Reg {
            deref: false,
            reg: Register::parse((self.code & 0x00000007)),
            writeback: false,
        }
    }
    /// Rn_3: First source operand register
    #[inline(always)]
    pub fn field_rn_3(&self) -> Reg {
        Reg {
            deref: false,
            reg: Register::parse(((self.code >> 3) & 0x00000007)),
            writeback: false,
        }
    }
    /// Rn_3_deref: Base register
    #[inline(always)]
    pub fn field_rn_3_deref(&self) -> Reg {
        Reg {
            deref: true,
            reg: Register::parse(((self.code >> 3) & 0x00000007)),
            writeback: false,
        }
    }
    /// Rn_8: First source operand register
    #[inline(always)]
    pub fn field_rn_8(&self) -> Reg {
        Reg {
            deref: false,
            reg: Register::parse(((self.code >> 8) & 0x00000007)),
            writeback: false,
        }
    }
    /// Rn_8_wb: First source operand register
    #[inline(always)]
    pub fn field_rn_8_wb(&self) -> Reg {
        Reg {
            deref: false,
            reg: Register::parse(((self.code >> 8) & 0x00000007)),
            writeback: true,
        }
    }
    /// Rn_H1: First source operand register
    #[inline(always)]
    pub fn field_rn_h1(&self) -> Reg {
        Reg {
            deref: false,
            reg: Register::parse(
                (self.code & 0x00000007) | ((self.code >> 7) & 0x00000001) << 3,
            ),
            writeback: false,
        }
    }
    /// Rm_3: Second source operand register
    #[inline(always)]
    pub fn field_rm_3(&self) -> Reg {
        Reg {
            deref: false,
            reg: Register::parse(((self.code >> 3) & 0x00000007)),
            writeback: false,
        }
    }
    /// Rm_6: Second source operand register
    #[inline(always)]
    pub fn field_rm_6(&self) -> Reg {
        Reg {
            deref: false,
            reg: Register::parse(((self.code >> 6) & 0x00000007)),
            writeback: false,
        }
    }
    /// Rm_6_offset: Offset register
    #[inline(always)]
    pub fn field_rm_6_offset(&self) -> OffsetReg {
        OffsetReg {
            add: true,
            post_indexed: false,
            reg: Register::parse(((self.code >> 6) & 0x00000007)),
        }
    }
    /// Rm_H2: Second source operand register
    #[inline(always)]
    pub fn field_rm_h2(&self) -> Reg {
        Reg {
            deref: false,
            reg: Register::parse(((self.code >> 3) & 0x0000000f)),
            writeback: false,
        }
    }
    /// Rs: Register containing shift offset
    #[inline(always)]
    pub fn field_rs(&self) -> Reg {
        Reg {
            deref: false,
            reg: Register::parse(((self.code >> 3) & 0x00000007)),
            writeback: false,
        }
    }
    /// pc: Program counter
    #[inline(always)]
    pub fn field_pc(&self) -> Reg {
        Reg {
            deref: false,
            reg: Register::parse(15),
            writeback: false,
        }
    }
    /// pc_deref: Program counter as base register
    #[inline(always)]
    pub fn field_pc_deref(&self) -> Reg {
        Reg {
            deref: true,
            reg: Register::parse(15),
            writeback: false,
        }
    }
    /// sp: Stack pointer
    #[inline(always)]
    pub fn field_sp(&self) -> Reg {
        Reg {
            deref: false,
            reg: Register::parse(13),
            writeback: false,
        }
    }
    /// sp_deref: Stack pointer as base register
    #[inline(always)]
    pub fn field_sp_deref(&self) -> Reg {
        Reg {
            deref: true,
            reg: Register::parse(13),
            writeback: false,
        }
    }
    /// registers: List of general-purpose registers
    #[inline(always)]
    pub fn field_registers(&self) -> RegList {
        RegList {
            regs: (self.code & 0x000000ff),
            user_mode: false,
        }
    }
    /// registers_pc: List of general-purpose registers, including PC
    #[inline(always)]
    pub fn field_registers_pc(&self) -> RegList {
        RegList {
            regs: (self.code & 0x000000ff) | ((self.code >> 8) & 0x00000001) << 15,
            user_mode: false,
        }
    }
    /// registers_lr: List of general-purpose registers, including LR
    #[inline(always)]
    pub fn field_registers_lr(&self) -> RegList {
        RegList {
            regs: (self.code & 0x000000ff) | ((self.code >> 8) & 0x00000001) << 14,
            user_mode: false,
        }
    }
    /// zero: Zero
    #[inline(always)]
    pub fn field_zero(&self) -> u32 {
        0
    }
    /// immed_3: 3-bit immediate
    #[inline(always)]
    pub fn field_immed_3(&self) -> u32 {
        ((self.code >> 6) & 0x00000007)
    }
    /// immed_8: 8-bit immediate
    #[inline(always)]
    pub fn field_immed_8(&self) -> u32 {
        (self.code & 0x000000ff)
    }
    /// rel_immed_7: Address-relative 7-bit immediate
    #[inline(always)]
    pub fn field_rel_immed_7(&self) -> u32 {
        (self.code & 0x0000007f) << 2
    }
    /// rel_immed_8: Address-relative 8-bit immediate
    #[inline(always)]
    pub fn field_rel_immed_8(&self) -> u32 {
        (self.code & 0x000000ff) << 2
    }
    /// left_shift_imm: 5-bit left shift offset
    #[inline(always)]
    pub fn field_left_shift_imm(&self) -> u32 {
        ((self.code >> 6) & 0x0000001f)
    }
    /// right_shift_imm: 5-bit right shift offset
    #[inline(always)]
    pub fn field_right_shift_imm(&self) -> u32 {
        {
            let value = ((self.code >> 6) & 0x0000001f);
            match 1 {
                1 | 2 => if value == 0 { 32 } else { value }
                _ => value,
            }
        }
    }
    /// branch_offset_8: 9-bit signed B/BL target offset
    #[inline(always)]
    pub fn field_branch_offset_8(&self) -> i32 {
        (((self.code & 0x000000ff) << 1) + 4) as i32
    }
    /// branch_offset_11: 12-bit signed B target offset
    #[inline(always)]
    pub fn field_branch_offset_11(&self) -> i32 {
        (((self.code & 0x000007ff) << 1) + 4) as i32
    }
    /// high_branch_offset_11: 23-bit signed BL/BLX target offset (high part)
    #[inline(always)]
    pub fn field_high_branch_offset_11(&self) -> i32 {
        (((self.code & 0x000007ff) << 12) + 4) as i32
    }
    /// low_branch_offset_11: 23-bit signed BL target offset (low part)
    #[inline(always)]
    pub fn field_low_branch_offset_11(&self) -> u32 {
        (self.code & 0x000007ff) << 1
    }
    /// low_blx_offset_11: 23-bit signed BLX target offset (low part)
    #[inline(always)]
    pub fn field_low_blx_offset_11(&self) -> u32 {
        (self.code & 0x000007ff) << 1 & !3
    }
    /// offset_5: 7-bit immediate offset
    #[inline(always)]
    pub fn field_offset_5(&self) -> OffsetImm {
        OffsetImm {
            post_indexed: false,
            value: (((self.code >> 6) & 0x0000001f) << 2) as i32,
        }
    }
    /// cpsr_flags: CPSR flags
    #[inline(always)]
    pub fn field_cpsr_flags(&self) -> CpsrFlags {
        CpsrFlags {
            a: (((self.code >> 2) & 0x00000001)) != 0,
            enable: (((self.code >> 4) & 0x00000001)) != 0,
            f: ((self.code & 0x00000001)) != 0,
            i: (((self.code >> 1) & 0x00000001)) != 0,
        }
    }
    /// endian: Endian specifier
    #[inline(always)]
    pub fn field_endian(&self) -> Endian {
        Endian::parse(((self.code >> 3) & 0x00000001))
    }
    /// imod: Modify interrupt flags
    #[inline(always)]
    pub const fn modifier_imod(&self) -> Imod {
        match self.code & 0x00000010 {
            0x00000000 => Imod::Ie,
            0x00000010 => Imod::Id,
            _ => Imod::Illegal,
        }
    }
    /// cond: Condition code
    #[inline(always)]
    pub const fn modifier_cond(&self) -> Cond {
        match self.code & 0x00000f00 {
            0x00000000 => Cond::Eq,
            0x00000100 => Cond::Ne,
            0x00000200 => Cond::Hs,
            0x00000300 => Cond::Lo,
            0x00000400 => Cond::Mi,
            0x00000500 => Cond::Pl,
            0x00000600 => Cond::Vs,
            0x00000700 => Cond::Vc,
            0x00000800 => Cond::Hi,
            0x00000900 => Cond::Ls,
            0x00000a00 => Cond::Ge,
            0x00000b00 => Cond::Lt,
            0x00000c00 => Cond::Gt,
            0x00000d00 => Cond::Le,
            0x00000e00 => Cond::Al,
            _ => Cond::Illegal,
        }
    }
}
/// imod: Modify interrupt flags
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Imod {
    Illegal,
    /// ie: Interrupt Enable
    Ie,
    /// id: Interrupt Disable
    Id,
}
/// cond: Condition code
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Cond {
    Illegal,
    /// eq: Equal
    Eq,
    /// ne: Not equal
    Ne,
    /// hs: Unsigned higher or same
    Hs,
    /// lo: Unsigned lower
    Lo,
    /// mi: Minus/negative
    Mi,
    /// pl: Plus/positive or zero
    Pl,
    /// vs: Overflow
    Vs,
    /// vc: No overflow
    Vc,
    /// hi: Unsigned higher
    Hi,
    /// ls: Unsigned lower or same
    Ls,
    /// ge: Signed greater than or equal
    Ge,
    /// lt: Signed less than
    Lt,
    /// gt: Signed greater than
    Gt,
    /// le: Signed less than or equal
    Le,
    /// al: Always
    Al,
}
fn parse_adcs(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "adcs",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rm_3()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_adds_3(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "adds",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rn_3()),
            Argument::UImm(ins.field_immed_3()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_adds_8(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "adds",
        args: [
            Argument::Reg(ins.field_rd_8()),
            Argument::UImm(ins.field_immed_8()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_adds_r(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "adds",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rn_3()),
            Argument::Reg(ins.field_rm_6()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_add_hr(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "add",
        args: [
            Argument::Reg(ins.field_rd_h1()),
            Argument::Reg(ins.field_rd_h1()),
            Argument::Reg(ins.field_rm_h2()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_add_sp(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "add",
        args: [
            Argument::Reg(ins.field_rd_8()),
            Argument::Reg(ins.field_sp()),
            Argument::UImm(ins.field_rel_immed_8()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_add_sp7(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "add",
        args: [
            Argument::Reg(ins.field_sp()),
            Argument::Reg(ins.field_sp()),
            Argument::UImm(ins.field_rel_immed_7()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_add_reg_sp(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "add",
        args: [
            Argument::Reg(ins.field_rd_h1()),
            Argument::Reg(ins.field_sp()),
            Argument::Reg(ins.field_rd_h1()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_add_sp_reg(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "add",
        args: [
            Argument::Reg(ins.field_sp()),
            Argument::Reg(ins.field_sp()),
            Argument::Reg(ins.field_rm_h2()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_adr(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "adr",
        args: [
            Argument::Reg(ins.field_rd_8()),
            Argument::UImm(ins.field_rel_immed_8()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_ands(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "ands",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rm_3()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_asrs_i(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "asrs",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rm_3()),
            Argument::UImm(ins.field_right_shift_imm()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_asrs_r(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "asrs",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rs()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_b(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = match ins.modifier_cond() {
        Cond::Eq => {
            ParsedIns {
                mnemonic: "beq",
                args: [
                    Argument::BranchDest(ins.field_branch_offset_8()),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        }
        Cond::Ne => {
            ParsedIns {
                mnemonic: "bne",
                args: [
                    Argument::BranchDest(ins.field_branch_offset_8()),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        }
        Cond::Hs => {
            ParsedIns {
                mnemonic: "bhs",
                args: [
                    Argument::BranchDest(ins.field_branch_offset_8()),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        }
        Cond::Lo => {
            ParsedIns {
                mnemonic: "blo",
                args: [
                    Argument::BranchDest(ins.field_branch_offset_8()),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        }
        Cond::Mi => {
            ParsedIns {
                mnemonic: "bmi",
                args: [
                    Argument::BranchDest(ins.field_branch_offset_8()),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        }
        Cond::Pl => {
            ParsedIns {
                mnemonic: "bpl",
                args: [
                    Argument::BranchDest(ins.field_branch_offset_8()),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        }
        Cond::Vs => {
            ParsedIns {
                mnemonic: "bvs",
                args: [
                    Argument::BranchDest(ins.field_branch_offset_8()),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        }
        Cond::Vc => {
            ParsedIns {
                mnemonic: "bvc",
                args: [
                    Argument::BranchDest(ins.field_branch_offset_8()),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        }
        Cond::Hi => {
            ParsedIns {
                mnemonic: "bhi",
                args: [
                    Argument::BranchDest(ins.field_branch_offset_8()),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        }
        Cond::Ls => {
            ParsedIns {
                mnemonic: "bls",
                args: [
                    Argument::BranchDest(ins.field_branch_offset_8()),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        }
        Cond::Ge => {
            ParsedIns {
                mnemonic: "bge",
                args: [
                    Argument::BranchDest(ins.field_branch_offset_8()),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        }
        Cond::Lt => {
            ParsedIns {
                mnemonic: "blt",
                args: [
                    Argument::BranchDest(ins.field_branch_offset_8()),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        }
        Cond::Gt => {
            ParsedIns {
                mnemonic: "bgt",
                args: [
                    Argument::BranchDest(ins.field_branch_offset_8()),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        }
        Cond::Le => {
            ParsedIns {
                mnemonic: "ble",
                args: [
                    Argument::BranchDest(ins.field_branch_offset_8()),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        }
        Cond::Al => {
            ParsedIns {
                mnemonic: "b",
                args: [
                    Argument::BranchDest(ins.field_branch_offset_8()),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        }
        _ => {
            ParsedIns {
                mnemonic: "<illegal>",
                args: [
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        }
    };
}
fn parse_b_long(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "b",
        args: [
            Argument::SImm(ins.field_branch_offset_11()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_bics(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "bics",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rm_3()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_bkpt(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "bkpt",
        args: [
            Argument::UImm(ins.field_immed_8()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_bl_h(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "bl",
        args: [
            Argument::SImm(ins.field_high_branch_offset_11()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_bl(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "bl",
        args: [
            Argument::UImm(ins.field_low_branch_offset_11()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_blx_i(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "blx",
        args: [
            Argument::UImm(ins.field_low_blx_offset_11()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_blx_r(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "blx",
        args: [
            Argument::Reg(ins.field_rm_h2()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_bx_r(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "bx",
        args: [
            Argument::Reg(ins.field_rm_h2()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_cmn(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "cmn",
        args: [
            Argument::Reg(ins.field_rn_0()),
            Argument::Reg(ins.field_rm_3()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_cmp_i(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "cmp",
        args: [
            Argument::Reg(ins.field_rn_8()),
            Argument::UImm(ins.field_immed_8()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_cmp_r(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "cmp",
        args: [
            Argument::Reg(ins.field_rn_0()),
            Argument::Reg(ins.field_rm_3()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_cmp_hr(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "cmp",
        args: [
            Argument::Reg(ins.field_rn_h1()),
            Argument::Reg(ins.field_rm_h2()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_cps(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = match ins.modifier_imod() {
        Imod::Ie => {
            ParsedIns {
                mnemonic: "cpsie",
                args: [
                    Argument::CpsrFlags(ins.field_cpsr_flags()),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        }
        Imod::Id => {
            ParsedIns {
                mnemonic: "cpsid",
                args: [
                    Argument::CpsrFlags(ins.field_cpsr_flags()),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        }
        _ => {
            ParsedIns {
                mnemonic: "<illegal>",
                args: [
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        }
    };
}
fn parse_eors(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "eors",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rm_3()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_ldm(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "ldm",
        args: [
            Argument::Reg(ins.field_rn_8_wb()),
            Argument::RegList(ins.field_registers()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_ldr_i(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "ldr",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rn_3_deref()),
            Argument::OffsetImm(ins.field_offset_5()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_ldr_r(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "ldr",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rn_3_deref()),
            Argument::OffsetReg(ins.field_rm_6_offset()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_ldr_pc(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "ldr",
        args: [
            Argument::Reg(ins.field_rd_8()),
            Argument::Reg(ins.field_pc_deref()),
            Argument::UImm(ins.field_rel_immed_8()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_ldr_sp(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "ldr",
        args: [
            Argument::Reg(ins.field_rd_8()),
            Argument::Reg(ins.field_sp_deref()),
            Argument::UImm(ins.field_rel_immed_8()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_ldrb_i(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "ldrb",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rn_3_deref()),
            Argument::OffsetImm(ins.field_offset_5()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_ldrb_r(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "ldrb",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rn_3_deref()),
            Argument::OffsetReg(ins.field_rm_6_offset()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_ldrh_i(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "ldrh",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rn_3_deref()),
            Argument::OffsetImm(ins.field_offset_5()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_ldrh_r(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "ldrh",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rn_3_deref()),
            Argument::OffsetReg(ins.field_rm_6_offset()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_ldrsb(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "ldrsb",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rn_3_deref()),
            Argument::OffsetReg(ins.field_rm_6_offset()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_ldrsh(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "ldrsh",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rn_3_deref()),
            Argument::OffsetReg(ins.field_rm_6_offset()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_lsls_i(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "lsls",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rm_3()),
            Argument::UImm(ins.field_left_shift_imm()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_lsls_r(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "lsls",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rs()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_lsrs_i(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "lsrs",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rm_3()),
            Argument::UImm(ins.field_right_shift_imm()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_lsrs_r(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "lsrs",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rs()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_movs_i(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "movs",
        args: [
            Argument::Reg(ins.field_rd_8()),
            Argument::UImm(ins.field_immed_8()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_movs_r(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "movs",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rn_3()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_mov_hr(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "mov",
        args: [
            Argument::Reg(ins.field_rd_h1()),
            Argument::Reg(ins.field_rm_h2()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_muls(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "muls",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rm_3()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_mvns(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "mvns",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rm_3()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_rsbs(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "rsbs",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rm_3()),
            Argument::UImm(ins.field_zero()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_orrs(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "orrs",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rm_3()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_pop(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "pop",
        args: [
            Argument::RegList(ins.field_registers_pc()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_push(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "push",
        args: [
            Argument::RegList(ins.field_registers_lr()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_rev(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "rev",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rn_3()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_rev16(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "rev16",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rn_3()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_revsh(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "revsh",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rn_3()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_rors(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "rors",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rs()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_sbcs(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "sbcs",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rm_3()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_setend(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "setend",
        args: [
            Argument::Endian(ins.field_endian()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_stm(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "stm",
        args: [
            Argument::Reg(ins.field_rn_8_wb()),
            Argument::RegList(ins.field_registers()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_str_i(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "str",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rn_3_deref()),
            Argument::OffsetImm(ins.field_offset_5()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_str_r(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "str",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rn_3_deref()),
            Argument::OffsetReg(ins.field_rm_6_offset()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_str_sp(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "str",
        args: [
            Argument::Reg(ins.field_rd_8()),
            Argument::Reg(ins.field_sp_deref()),
            Argument::UImm(ins.field_rel_immed_8()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_strb_i(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "strb",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rn_3_deref()),
            Argument::OffsetImm(ins.field_offset_5()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_strb_r(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "strb",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rn_3_deref()),
            Argument::OffsetReg(ins.field_rm_6_offset()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_strh_i(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "strh",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rn_3_deref()),
            Argument::OffsetImm(ins.field_offset_5()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_strh_r(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "strh",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rn_3_deref()),
            Argument::OffsetReg(ins.field_rm_6_offset()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_subs_3(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "subs",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rn_3()),
            Argument::UImm(ins.field_immed_3()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_subs_8(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "subs",
        args: [
            Argument::Reg(ins.field_rd_8()),
            Argument::UImm(ins.field_immed_8()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_subs_r(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "subs",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rn_3()),
            Argument::Reg(ins.field_rm_6()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_sub_sp7(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "sub",
        args: [
            Argument::Reg(ins.field_sp()),
            Argument::Reg(ins.field_sp()),
            Argument::UImm(ins.field_rel_immed_7()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_svc(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "svc",
        args: [
            Argument::UImm(ins.field_immed_8()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_sxtb(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "sxtb",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rm_3()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_sxth(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "sxth",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rm_3()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_tst(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "tst",
        args: [
            Argument::Reg(ins.field_rn_0()),
            Argument::Reg(ins.field_rm_3()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_uxtb(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "uxtb",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rm_3()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_uxth(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "uxth",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rm_3()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
type MnemonicParser = fn(&mut ParsedIns, Ins, &ParseFlags);
static MNEMONIC_PARSERS: [MnemonicParser; 76] = [
    parse_adcs,
    parse_adds_3,
    parse_adds_8,
    parse_adds_r,
    parse_add_hr,
    parse_add_sp,
    parse_add_sp7,
    parse_add_reg_sp,
    parse_add_sp_reg,
    parse_adr,
    parse_ands,
    parse_asrs_i,
    parse_asrs_r,
    parse_b,
    parse_b_long,
    parse_bics,
    parse_bkpt,
    parse_bl_h,
    parse_bl,
    parse_blx_i,
    parse_blx_r,
    parse_bx_r,
    parse_cmn,
    parse_cmp_i,
    parse_cmp_r,
    parse_cmp_hr,
    parse_cps,
    parse_eors,
    parse_ldm,
    parse_ldr_i,
    parse_ldr_r,
    parse_ldr_pc,
    parse_ldr_sp,
    parse_ldrb_i,
    parse_ldrb_r,
    parse_ldrh_i,
    parse_ldrh_r,
    parse_ldrsb,
    parse_ldrsh,
    parse_lsls_i,
    parse_lsls_r,
    parse_lsrs_i,
    parse_lsrs_r,
    parse_movs_i,
    parse_movs_r,
    parse_mov_hr,
    parse_muls,
    parse_mvns,
    parse_rsbs,
    parse_orrs,
    parse_pop,
    parse_push,
    parse_rev,
    parse_rev16,
    parse_revsh,
    parse_rors,
    parse_sbcs,
    parse_setend,
    parse_stm,
    parse_str_i,
    parse_str_r,
    parse_str_sp,
    parse_strb_i,
    parse_strb_r,
    parse_strh_i,
    parse_strh_r,
    parse_subs_3,
    parse_subs_8,
    parse_subs_r,
    parse_sub_sp7,
    parse_svc,
    parse_sxtb,
    parse_sxth,
    parse_tst,
    parse_uxtb,
    parse_uxth,
];
#[inline]
pub fn parse(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    if ins.op != Opcode::Illegal {
        MNEMONIC_PARSERS[ins.op as usize](out, ins, flags);
    } else {
        *out = ParsedIns {
            mnemonic: "<illegal>",
            args: [
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
    }
}
