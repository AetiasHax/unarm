#![cfg_attr(rustfmt, rustfmt_skip)]
#![allow(unused)]
#![allow(clippy::double_parens, clippy::unnecessary_cast)]
// Generated by unarm-generator. Do not edit!
use crate::{ArmVersion, ParseFlags, args::*, parse::ParsedIns};
use super::Ins;
/// These are the mnemonics of each opcode. Some mnemonics are duplicated due to them having multiple formats.
static OPCODE_MNEMONICS: [&str; 81] = [
    "adcs",
    "adds",
    "adds",
    "adds",
    "add",
    "add",
    "add",
    "add",
    "add",
    "add",
    "adr",
    "ands",
    "asrs",
    "asrs",
    "b",
    "b",
    "bics",
    "bkpt",
    "bl",
    "bl",
    "blx",
    "blx",
    "bx",
    "cmn",
    "cmp",
    "cmp",
    "cmp",
    "cps",
    "eors",
    "ldm",
    "ldmia",
    "ldr",
    "ldr",
    "ldr",
    "ldr",
    "ldrb",
    "ldrb",
    "ldrh",
    "ldrh",
    "ldrsb",
    "ldrsh",
    "lsls",
    "lsls",
    "lsrs",
    "lsrs",
    "movs",
    "mov",
    "movs",
    "mov",
    "muls",
    "mvns",
    "neg",
    "rsbs",
    "orrs",
    "pop",
    "push",
    "rev",
    "rev16",
    "revsh",
    "rors",
    "sbcs",
    "setend",
    "stm",
    "str",
    "str",
    "str",
    "strb",
    "strb",
    "strh",
    "strh",
    "subs",
    "subs",
    "subs",
    "sub",
    "svc",
    "swi",
    "sxtb",
    "sxth",
    "tst",
    "uxtb",
    "uxth",
];
#[derive(Clone, Copy, Debug, Default, PartialEq, Eq)]
#[repr(u8)]
#[non_exhaustive]
pub enum Opcode {
    /// Illegal or unknown
    #[default]
    Illegal = u8::MAX,
    /// ADCS: Add with Carry
    Adc = 0,
    /// ADDS: Add 3-bit immediate
    Add3 = 1,
    /// ADDS: Add 8-bit immediate
    Add8 = 2,
    /// ADDS: Add register
    AddR = 3,
    /// ADD: Add high register
    AddHr = 4,
    /// ADD: Add SP-relative address
    AddSp = 5,
    /// ADD: Add 7-bit immediate multiple of 4 to SP
    AddSp7 = 6,
    /// ADD: Add SP to register
    AddRegSp = 7,
    /// ADD: Add register to SP
    AddSpReg = 8,
    /// ADD: Add 8-bit immediate multiple of 4 to PC
    AddPc = 9,
    /// ADR: Add PC-relative address
    Adr = 10,
    /// ANDS: Bitwise AND
    And = 11,
    /// ASRS: Arithmetic Shift Right by 5-bit immediate
    AsrI = 12,
    /// ASRS: Arithmetic Shift Right by register
    AsrR = 13,
    /// B: Branch
    B = 14,
    /// B: Branch (unconditional, long)
    BLong = 15,
    /// BICS: Bit Clear
    Bic = 16,
    /// BKPT: Breakpoint
    Bkpt = 17,
    /// BL: Branch and Link (high part)
    BlH = 18,
    /// BL: Branch and Link (low part)
    Bl = 19,
    /// BLX: Branch and Link and Exchange to ARM (low part, immediate target)
    BlxI = 20,
    /// BLX: Branch and Link and Exchange to ARM (register target)
    BlxR = 21,
    /// BX: Branch and Exchange
    BxR = 22,
    /// CMN: Compare Negative
    Cmn = 23,
    /// CMP: Compare with immediate
    CmpI = 24,
    /// CMP: Compare with register
    CmpR = 25,
    /// CMP: Compare with high register
    CmpHr = 26,
    /// CPS: Change Processor State
    Cps = 27,
    /// EORS: Exclusive OR
    Eor = 28,
    /// LDM: Load Multiple
    Ldm = 29,
    /// LDMIA: Load Multiple
    Ldmia = 30,
    /// LDR: Load Register with immediate offset
    LdrI = 31,
    /// LDR: Load Register with register offset
    LdrR = 32,
    /// LDR: Load Register with PC-relative address
    LdrPc = 33,
    /// LDR: Load Register with SP-relative address
    LdrSp = 34,
    /// LDRB: Load Register Byte with immediate offset
    LdrbI = 35,
    /// LDRB: Load Register Byte with register offset
    LdrbR = 36,
    /// LDRH: Load Register Halfword with immediate offset
    LdrhI = 37,
    /// LDRH: Load Register Halfword with register offset
    LdrhR = 38,
    /// LDRSB: Load Register Signed Byte
    Ldrsb = 39,
    /// LDRSH: Load Register Signed Halfword
    Ldrsh = 40,
    /// LSLS: Logical Shift Left by 5-bit immediate
    LslI = 41,
    /// LSLS: Logical Shift Left by register
    LslR = 42,
    /// LSRS: Logical Shift Right by 5-bit immediate
    LsrI = 43,
    /// LSRS: Logical Shift Right by register
    LsrR = 44,
    /// MOVS: Move immediate
    MovI = 45,
    /// MOV: Move register
    MovR = 46,
    /// MOVS: Move register
    MovsR = 47,
    /// MOV: Move high register
    MovHr = 48,
    /// MULS: Multiply
    Mul = 49,
    /// MVNS: Move Negative
    Mvn = 50,
    /// NEG: Negate
    Neg = 51,
    /// RSBS: Negate
    Rsbs = 52,
    /// ORRS: Bitwise OR
    Orr = 53,
    /// POP: Pop multiple registers
    Pop = 54,
    /// PUSH: Push multiple registers
    Push = 55,
    /// REV: Byte-Reverse Word
    Rev = 56,
    /// REV16: Byte-Reverse Packed Halfword
    Rev16 = 57,
    /// REVSH: Byte-Reverse Signed Halfword
    Revsh = 58,
    /// RORS: Rotate Right
    Ror = 59,
    /// SBCS: Subtract with Carry
    Sbc = 60,
    /// SETEND: Set Endian
    Setend = 61,
    /// STM: Store Multiple
    Stm = 62,
    /// STR: Store Register with immediate offset
    StrI = 63,
    /// STR: Store Register with register offset
    StrR = 64,
    /// STR: Store Register with SP-relative address
    StrSp = 65,
    /// STRB: Store Register Byte with immediate offset
    StrbI = 66,
    /// STRB: Store Register Byte with register offset
    StrbR = 67,
    /// STRH: Store Register Halfword with immediate offset
    StrhI = 68,
    /// STRH: Store Register Halfword with register offset
    StrhR = 69,
    /// SUBS: Subtract 3-bit immediate
    Subs3 = 70,
    /// SUBS: Subtract 8-bit immediate
    Sub8 = 71,
    /// SUBS: Subtract register
    SubR = 72,
    /// SUB: Subtract 7-bit immediate multiple of 4 from SP
    SubSp7 = 73,
    /// SVC: Supervisor Call
    Svc = 74,
    /// SWI: Software Interrupt
    Swi = 75,
    /// SXTB: Sign Extend Byte to 32 bits
    Sxtb = 76,
    /// SXTH: Sign Extend Halfword to 32 bits
    Sxth = 77,
    /// TST: Test
    Tst = 78,
    /// UXTB: Zero Extend Byte to 32 bits
    Uxtb = 79,
    /// UXTH: Zero Extend Halfword to 32 bits
    Uxth = 80,
}
impl Opcode {
    #[inline]
    pub fn find(code: u32, flags: &ParseFlags) -> Self {
        if (code & 0x00001000) == 0x00000000 {
            if (code & 0x00000400) == 0x00000400 {
                if (code & 0x00008000) == 0x00000000 {
                    if (code & 0x00000100) == 0x00000100 {
                        if (code & 0x00000800) == 0x00000000 {
                            if (code & 0x00000200) == 0x00000000 {
                                if (code & 0x00002000) == 0x00000000 {
                                    if (code & 0x00004000) == 0x00000000 {
                                        if (code & 0x0000f800) == 0x00000000 {
                                            return Opcode::LslI;
                                        }
                                    } else {
                                        if (code & 0x0000ff00) == 0x00004500 {
                                            return Opcode::CmpHr;
                                        }
                                    }
                                } else {
                                    if (code & 0x00004000) == 0x00000000 {
                                        if (code & 0x0000f800) == 0x00002000 {
                                            return Opcode::MovI;
                                        }
                                    } else {
                                        if (code & 0x0000f800) == 0x00006000 {
                                            return Opcode::StrI;
                                        }
                                    }
                                }
                            } else {
                                if (code & 0x00002000) == 0x00002000 {
                                    if (code & 0x00004000) == 0x00000000 {
                                        if (code & 0x0000f800) == 0x00002000 {
                                            return Opcode::MovI;
                                        }
                                    } else {
                                        if (code & 0x0000f800) == 0x00006000 {
                                            return Opcode::StrI;
                                        }
                                    }
                                } else {
                                    if (code & 0x00004000) == 0x00000000 {
                                        if (code & 0x0000f800) == 0x00000000 {
                                            return Opcode::LslI;
                                        }
                                    } else {
                                        if (code & 0x00000080) == 0x00000000 {
                                            if (code & 0x0000ff87) == 0x00004700 {
                                                return Opcode::BxR;
                                            }
                                        } else {
                                            #[cfg(any(feature = "v5te", feature = "v6k"))]
                                            if flags.version >= ArmVersion::V5Te
                                                && (code & 0x0000ff87) == 0x00004780
                                            {
                                                return Opcode::BlxR;
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if (code & 0x00002000) == 0x00000000 {
                                if (code & 0x00004000) == 0x00000000 {
                                    if (code & 0x0000f800) == 0x00000800 {
                                        return Opcode::LsrI;
                                    }
                                } else {
                                    if (code & 0x0000f800) == 0x00004800 {
                                        return Opcode::LdrPc;
                                    }
                                }
                            } else {
                                if (code & 0x00004000) == 0x00000000 {
                                    if (code & 0x0000f800) == 0x00002800 {
                                        return Opcode::CmpI;
                                    }
                                } else {
                                    if (code & 0x0000f800) == 0x00006800 {
                                        return Opcode::LdrI;
                                    }
                                }
                            }
                        }
                    } else {
                        if (code & 0x00000800) == 0x00000000 {
                            if (code & 0x00000200) == 0x00000200 {
                                if (code & 0x00002000) == 0x00000000 {
                                    if (code & 0x00004000) == 0x00000000 {
                                        if (code & 0x0000f800) == 0x00000000 {
                                            return Opcode::LslI;
                                        }
                                    } else {
                                        if (code & 0x0000ff00) == 0x00004600 {
                                            return Opcode::MovHr;
                                        }
                                    }
                                } else {
                                    if (code & 0x00004000) == 0x00000000 {
                                        if (code & 0x0000f800) == 0x00002000 {
                                            return Opcode::MovI;
                                        }
                                    } else {
                                        if (code & 0x0000f800) == 0x00006000 {
                                            return Opcode::StrI;
                                        }
                                    }
                                }
                            } else {
                                if (code & 0x00002000) == 0x00000000 {
                                    if (code & 0x00004000) == 0x00004000 {
                                        if (code & 0x0000ff78) == 0x00004468 {
                                            return Opcode::AddRegSp;
                                        }
                                        if (code & 0x0000ff87) == 0x00004485 {
                                            return Opcode::AddSpReg;
                                        }
                                        if (code & 0x0000ff00) == 0x00004400 {
                                            return Opcode::AddHr;
                                        }
                                    } else {
                                        if (code & 0x0000f800) == 0x00000000 {
                                            return Opcode::LslI;
                                        }
                                    }
                                } else {
                                    if (code & 0x00004000) == 0x00000000 {
                                        if (code & 0x0000f800) == 0x00002000 {
                                            return Opcode::MovI;
                                        }
                                    } else {
                                        if (code & 0x0000f800) == 0x00006000 {
                                            return Opcode::StrI;
                                        }
                                    }
                                }
                            }
                        } else {
                            if (code & 0x00002000) == 0x00000000 {
                                if (code & 0x00004000) == 0x00000000 {
                                    if (code & 0x0000f800) == 0x00000800 {
                                        return Opcode::LsrI;
                                    }
                                } else {
                                    if (code & 0x0000f800) == 0x00004800 {
                                        return Opcode::LdrPc;
                                    }
                                }
                            } else {
                                if (code & 0x00004000) == 0x00000000 {
                                    if (code & 0x0000f800) == 0x00002800 {
                                        return Opcode::CmpI;
                                    }
                                } else {
                                    if (code & 0x0000f800) == 0x00006800 {
                                        return Opcode::LdrI;
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if (code & 0x00000800) == 0x00000000 {
                        if (code & 0x00002000) == 0x00000000 {
                            if (code & 0x00004000) == 0x00000000 {
                                if (code & 0x0000f800) == 0x00008000 {
                                    return Opcode::StrhI;
                                }
                            } else {
                                if (code & 0x0000f800) == 0x0000c000 {
                                    return Opcode::Stm;
                                }
                            }
                        } else {
                            if (code & 0x00004000) == 0x00004000 {
                                if (code & 0x0000f800) == 0x0000e000 {
                                    return Opcode::BLong;
                                }
                            } else {
                                if !flags.ual && (code & 0x0000f800) == 0x0000a000 {
                                    return Opcode::AddPc;
                                }
                                if flags.ual && (code & 0x0000f800) == 0x0000a000 {
                                    return Opcode::Adr;
                                }
                            }
                        }
                    } else {
                        if (code & 0x00002000) == 0x00002000 {
                            if (code & 0x00004000) == 0x00000000 {
                                if (code & 0x0000f800) == 0x0000a800 {
                                    return Opcode::AddSp;
                                }
                            } else {
                                #[cfg(any(feature = "v5te", feature = "v6k"))]
                                if flags.version >= ArmVersion::V5Te
                                    && (code & 0x0000f800) == 0x0000e800
                                {
                                    return Opcode::BlxI;
                                }
                            }
                        } else {
                            if (code & 0x00004000) == 0x00000000 {
                                if (code & 0x0000f800) == 0x00008800 {
                                    return Opcode::LdrhI;
                                }
                            } else {
                                if flags.ual && (code & 0x0000f800) == 0x0000c800 {
                                    return Opcode::Ldm;
                                }
                                if !flags.ual && (code & 0x0000f800) == 0x0000c800 {
                                    return Opcode::Ldmia;
                                }
                            }
                        }
                    }
                }
            } else {
                if (code & 0x00000080) == 0x00000080 {
                    if (code & 0x00008000) == 0x00000000 {
                        if (code & 0x00000040) == 0x00000000 {
                            if (code & 0x00000800) == 0x00000000 {
                                if (code & 0x00000100) == 0x00000000 {
                                    if (code & 0x00002000) == 0x00002000 {
                                        if (code & 0x00004000) == 0x00000000 {
                                            if (code & 0x0000f800) == 0x00002000 {
                                                return Opcode::MovI;
                                            }
                                        } else {
                                            if (code & 0x0000f800) == 0x00006000 {
                                                return Opcode::StrI;
                                            }
                                        }
                                    } else {
                                        if (code & 0x00004000) == 0x00000000 {
                                            if (code & 0x0000f800) == 0x00000000 {
                                                return Opcode::LslI;
                                            }
                                        } else {
                                            if (code & 0x00000200) == 0x00000000 {
                                                if (code & 0x0000ffc0) == 0x00004080 {
                                                    return Opcode::LslR;
                                                }
                                            } else {
                                                if (code & 0x0000ffc0) == 0x00004280 {
                                                    return Opcode::CmpR;
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if (code & 0x00002000) == 0x00002000 {
                                        if (code & 0x00004000) == 0x00000000 {
                                            if (code & 0x0000f800) == 0x00002000 {
                                                return Opcode::MovI;
                                            }
                                        } else {
                                            if (code & 0x0000f800) == 0x00006000 {
                                                return Opcode::StrI;
                                            }
                                        }
                                    } else {
                                        if (code & 0x00004000) == 0x00000000 {
                                            if (code & 0x0000f800) == 0x00000000 {
                                                return Opcode::LslI;
                                            }
                                        } else {
                                            if (code & 0x00000200) == 0x00000000 {
                                                if (code & 0x0000ffc0) == 0x00004180 {
                                                    return Opcode::Sbc;
                                                }
                                            } else {
                                                if (code & 0x0000ffc0) == 0x00004380 {
                                                    return Opcode::Bic;
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if (code & 0x00002000) == 0x00000000 {
                                    if (code & 0x00004000) == 0x00000000 {
                                        if (code & 0x0000f800) == 0x00000800 {
                                            return Opcode::LsrI;
                                        }
                                    } else {
                                        if (code & 0x0000f800) == 0x00004800 {
                                            return Opcode::LdrPc;
                                        }
                                    }
                                } else {
                                    if (code & 0x00004000) == 0x00000000 {
                                        if (code & 0x0000f800) == 0x00002800 {
                                            return Opcode::CmpI;
                                        }
                                    } else {
                                        if (code & 0x0000f800) == 0x00006800 {
                                            return Opcode::LdrI;
                                        }
                                    }
                                }
                            }
                        } else {
                            if (code & 0x00000800) == 0x00000000 {
                                if (code & 0x00000100) == 0x00000000 {
                                    if (code & 0x00002000) == 0x00002000 {
                                        if (code & 0x00004000) == 0x00000000 {
                                            if (code & 0x0000f800) == 0x00002000 {
                                                return Opcode::MovI;
                                            }
                                        } else {
                                            if (code & 0x0000f800) == 0x00006000 {
                                                return Opcode::StrI;
                                            }
                                        }
                                    } else {
                                        if (code & 0x00004000) == 0x00000000 {
                                            if (code & 0x0000f800) == 0x00000000 {
                                                return Opcode::LslI;
                                            }
                                        } else {
                                            if (code & 0x00000200) == 0x00000000 {
                                                if (code & 0x0000ffc0) == 0x000040c0 {
                                                    return Opcode::LsrR;
                                                }
                                            } else {
                                                if (code & 0x0000ffc0) == 0x000042c0 {
                                                    return Opcode::Cmn;
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if (code & 0x00002000) == 0x00002000 {
                                        if (code & 0x00004000) == 0x00000000 {
                                            if (code & 0x0000f800) == 0x00002000 {
                                                return Opcode::MovI;
                                            }
                                        } else {
                                            if (code & 0x0000f800) == 0x00006000 {
                                                return Opcode::StrI;
                                            }
                                        }
                                    } else {
                                        if (code & 0x00004000) == 0x00000000 {
                                            if (code & 0x0000f800) == 0x00000000 {
                                                return Opcode::LslI;
                                            }
                                        } else {
                                            if (code & 0x00000200) == 0x00000000 {
                                                if (code & 0x0000ffc0) == 0x000041c0 {
                                                    return Opcode::Ror;
                                                }
                                            } else {
                                                if (code & 0x0000ffc0) == 0x000043c0 {
                                                    return Opcode::Mvn;
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if (code & 0x00002000) == 0x00000000 {
                                    if (code & 0x00004000) == 0x00000000 {
                                        if (code & 0x0000f800) == 0x00000800 {
                                            return Opcode::LsrI;
                                        }
                                    } else {
                                        if (code & 0x0000f800) == 0x00004800 {
                                            return Opcode::LdrPc;
                                        }
                                    }
                                } else {
                                    if (code & 0x00004000) == 0x00000000 {
                                        if (code & 0x0000f800) == 0x00002800 {
                                            return Opcode::CmpI;
                                        }
                                    } else {
                                        if (code & 0x0000f800) == 0x00006800 {
                                            return Opcode::LdrI;
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if (code & 0x00000800) == 0x00000000 {
                            if (code & 0x00002000) == 0x00000000 {
                                if (code & 0x00004000) == 0x00000000 {
                                    if (code & 0x0000f800) == 0x00008000 {
                                        return Opcode::StrhI;
                                    }
                                } else {
                                    if (code & 0x0000f800) == 0x0000c000 {
                                        return Opcode::Stm;
                                    }
                                }
                            } else {
                                if (code & 0x00004000) == 0x00004000 {
                                    if (code & 0x0000f800) == 0x0000e000 {
                                        return Opcode::BLong;
                                    }
                                } else {
                                    if !flags.ual && (code & 0x0000f800) == 0x0000a000 {
                                        return Opcode::AddPc;
                                    }
                                    if flags.ual && (code & 0x0000f800) == 0x0000a000 {
                                        return Opcode::Adr;
                                    }
                                }
                            }
                        } else {
                            if (code & 0x00002000) == 0x00002000 {
                                if (code & 0x00004000) == 0x00000000 {
                                    if (code & 0x0000f800) == 0x0000a800 {
                                        return Opcode::AddSp;
                                    }
                                } else {
                                    #[cfg(any(feature = "v5te", feature = "v6k"))]
                                    if flags.version >= ArmVersion::V5Te
                                        && (code & 0x0000f800) == 0x0000e800
                                    {
                                        return Opcode::BlxI;
                                    }
                                }
                            } else {
                                if (code & 0x00004000) == 0x00000000 {
                                    if (code & 0x0000f800) == 0x00008800 {
                                        return Opcode::LdrhI;
                                    }
                                } else {
                                    if flags.ual && (code & 0x0000f800) == 0x0000c800 {
                                        return Opcode::Ldm;
                                    }
                                    if !flags.ual && (code & 0x0000f800) == 0x0000c800 {
                                        return Opcode::Ldmia;
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if (code & 0x00004000) == 0x00004000 {
                        if (code & 0x00000040) == 0x00000000 {
                            if (code & 0x00000800) == 0x00000000 {
                                if (code & 0x00000100) == 0x00000000 {
                                    if (code & 0x00002000) == 0x00002000 {
                                        if (code & 0x00008000) == 0x00000000 {
                                            if (code & 0x0000f800) == 0x00006000 {
                                                return Opcode::StrI;
                                            }
                                        } else {
                                            if (code & 0x0000f800) == 0x0000e000 {
                                                return Opcode::BLong;
                                            }
                                        }
                                    } else {
                                        if (code & 0x00008000) == 0x00008000 {
                                            if (code & 0x0000f800) == 0x0000c000 {
                                                return Opcode::Stm;
                                            }
                                        } else {
                                            if (code & 0x00000200) == 0x00000000 {
                                                if (code & 0x0000ffc0) == 0x00004000 {
                                                    return Opcode::And;
                                                }
                                            } else {
                                                if (code & 0x0000ffc0) == 0x00004200 {
                                                    return Opcode::Tst;
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if (code & 0x00002000) == 0x00002000 {
                                        if (code & 0x00008000) == 0x00000000 {
                                            if (code & 0x0000f800) == 0x00006000 {
                                                return Opcode::StrI;
                                            }
                                        } else {
                                            if (code & 0x0000f800) == 0x0000e000 {
                                                return Opcode::BLong;
                                            }
                                        }
                                    } else {
                                        if (code & 0x00008000) == 0x00008000 {
                                            if (code & 0x0000f800) == 0x0000c000 {
                                                return Opcode::Stm;
                                            }
                                        } else {
                                            if (code & 0x00000200) == 0x00000000 {
                                                if (code & 0x0000ffc0) == 0x00004100 {
                                                    return Opcode::AsrR;
                                                }
                                            } else {
                                                if (code & 0x0000ffc0) == 0x00004300 {
                                                    return Opcode::Orr;
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if (code & 0x00002000) == 0x00002000 {
                                    if (code & 0x00008000) == 0x00000000 {
                                        if (code & 0x0000f800) == 0x00006800 {
                                            return Opcode::LdrI;
                                        }
                                    } else {
                                        #[cfg(any(feature = "v5te", feature = "v6k"))]
                                        if flags.version >= ArmVersion::V5Te
                                            && (code & 0x0000f800) == 0x0000e800
                                        {
                                            return Opcode::BlxI;
                                        }
                                    }
                                } else {
                                    if (code & 0x00008000) == 0x00000000 {
                                        if (code & 0x0000f800) == 0x00004800 {
                                            return Opcode::LdrPc;
                                        }
                                    } else {
                                        if flags.ual && (code & 0x0000f800) == 0x0000c800 {
                                            return Opcode::Ldm;
                                        }
                                        if !flags.ual && (code & 0x0000f800) == 0x0000c800 {
                                            return Opcode::Ldmia;
                                        }
                                    }
                                }
                            }
                        } else {
                            if (code & 0x00000800) == 0x00000000 {
                                if (code & 0x00000100) == 0x00000100 {
                                    if (code & 0x00002000) == 0x00002000 {
                                        if (code & 0x00008000) == 0x00000000 {
                                            if (code & 0x0000f800) == 0x00006000 {
                                                return Opcode::StrI;
                                            }
                                        } else {
                                            if (code & 0x0000f800) == 0x0000e000 {
                                                return Opcode::BLong;
                                            }
                                        }
                                    } else {
                                        if (code & 0x00008000) == 0x00008000 {
                                            if (code & 0x0000f800) == 0x0000c000 {
                                                return Opcode::Stm;
                                            }
                                        } else {
                                            if (code & 0x00000200) == 0x00000000 {
                                                if (code & 0x0000ffc0) == 0x00004140 {
                                                    return Opcode::Adc;
                                                }
                                            } else {
                                                if (code & 0x0000ffc0) == 0x00004340 {
                                                    return Opcode::Mul;
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if (code & 0x00000200) == 0x00000000 {
                                        if (code & 0x00002000) == 0x00000000 {
                                            if (code & 0x00008000) == 0x00000000 {
                                                if (code & 0x0000ffc0) == 0x00004040 {
                                                    return Opcode::Eor;
                                                }
                                            } else {
                                                if (code & 0x0000f800) == 0x0000c000 {
                                                    return Opcode::Stm;
                                                }
                                            }
                                        } else {
                                            if (code & 0x00008000) == 0x00000000 {
                                                if (code & 0x0000f800) == 0x00006000 {
                                                    return Opcode::StrI;
                                                }
                                            } else {
                                                if (code & 0x0000f800) == 0x0000e000 {
                                                    return Opcode::BLong;
                                                }
                                            }
                                        }
                                    } else {
                                        if (code & 0x00002000) == 0x00002000 {
                                            if (code & 0x00008000) == 0x00000000 {
                                                if (code & 0x0000f800) == 0x00006000 {
                                                    return Opcode::StrI;
                                                }
                                            } else {
                                                if (code & 0x0000f800) == 0x0000e000 {
                                                    return Opcode::BLong;
                                                }
                                            }
                                        } else {
                                            if (code & 0x00008000) == 0x00008000 {
                                                if (code & 0x0000f800) == 0x0000c000 {
                                                    return Opcode::Stm;
                                                }
                                            } else {
                                                if !flags.ual && (code & 0x0000ffc0) == 0x00004240 {
                                                    return Opcode::Neg;
                                                }
                                                if flags.ual && (code & 0x0000ffc0) == 0x00004240 {
                                                    return Opcode::Rsbs;
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if (code & 0x00002000) == 0x00002000 {
                                    if (code & 0x00008000) == 0x00000000 {
                                        if (code & 0x0000f800) == 0x00006800 {
                                            return Opcode::LdrI;
                                        }
                                    } else {
                                        #[cfg(any(feature = "v5te", feature = "v6k"))]
                                        if flags.version >= ArmVersion::V5Te
                                            && (code & 0x0000f800) == 0x0000e800
                                        {
                                            return Opcode::BlxI;
                                        }
                                    }
                                } else {
                                    if (code & 0x00008000) == 0x00000000 {
                                        if (code & 0x0000f800) == 0x00004800 {
                                            return Opcode::LdrPc;
                                        }
                                    } else {
                                        if flags.ual && (code & 0x0000f800) == 0x0000c800 {
                                            return Opcode::Ldm;
                                        }
                                        if !flags.ual && (code & 0x0000f800) == 0x0000c800 {
                                            return Opcode::Ldmia;
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if (code & 0x00002000) == 0x00000000 {
                            if (code & 0x00000800) == 0x00000800 {
                                if (code & 0x00008000) == 0x00000000 {
                                    if (code & 0x0000f800) == 0x00000800 {
                                        return Opcode::LsrI;
                                    }
                                } else {
                                    if (code & 0x0000f800) == 0x00008800 {
                                        return Opcode::LdrhI;
                                    }
                                }
                            } else {
                                if (code & 0x00008000) == 0x00008000 {
                                    if (code & 0x0000f800) == 0x00008000 {
                                        return Opcode::StrhI;
                                    }
                                } else {
                                    if flags.ual && (code & 0x0000ffc0) == 0x00000000 {
                                        return Opcode::MovsR;
                                    }
                                    if (code & 0x0000f800) == 0x00000000 {
                                        return Opcode::LslI;
                                    }
                                }
                            }
                        } else {
                            if (code & 0x00000800) == 0x00000800 {
                                if (code & 0x00008000) == 0x00000000 {
                                    if (code & 0x0000f800) == 0x00002800 {
                                        return Opcode::CmpI;
                                    }
                                } else {
                                    if (code & 0x0000f800) == 0x0000a800 {
                                        return Opcode::AddSp;
                                    }
                                }
                            } else {
                                if (code & 0x00008000) == 0x00000000 {
                                    if (code & 0x0000f800) == 0x00002000 {
                                        return Opcode::MovI;
                                    }
                                } else {
                                    if !flags.ual && (code & 0x0000f800) == 0x0000a000 {
                                        return Opcode::AddPc;
                                    }
                                    if flags.ual && (code & 0x0000f800) == 0x0000a000 {
                                        return Opcode::Adr;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        } else {
            if (code & 0x00000800) == 0x00000000 {
                if (code & 0x00000200) == 0x00000000 {
                    if (code & 0x00002000) == 0x00000000 {
                        if (code & 0x00004000) == 0x00000000 {
                            if (code & 0x00008000) == 0x00000000 {
                                if (code & 0x0000f800) == 0x00001000 {
                                    return Opcode::AsrI;
                                }
                            } else {
                                if (code & 0x0000f800) == 0x00009000 {
                                    return Opcode::StrSp;
                                }
                            }
                        } else {
                            if (code & 0x00008000) == 0x00008000 {
                                if (code & 0x0000f000) == 0x0000d000 {
                                    return Opcode::B;
                                }
                            } else {
                                if (code & 0x00000400) == 0x00000000 {
                                    if (code & 0x0000fe00) == 0x00005000 {
                                        return Opcode::StrR;
                                    }
                                } else {
                                    if (code & 0x0000fe00) == 0x00005400 {
                                        return Opcode::StrbR;
                                    }
                                }
                            }
                        }
                    } else {
                        if (code & 0x00000400) == 0x00000400 {
                            if (code & 0x00004000) == 0x00000000 {
                                if (code & 0x00008000) == 0x00000000 {
                                    if (code & 0x0000f800) == 0x00003000 {
                                        return Opcode::Add8;
                                    }
                                } else {
                                    if (code & 0x0000fe00) == 0x0000b400 {
                                        return Opcode::Push;
                                    }
                                }
                            } else {
                                if (code & 0x00008000) == 0x00000000 {
                                    if (code & 0x0000f800) == 0x00007000 {
                                        return Opcode::StrbI;
                                    }
                                } else {
                                    if (code & 0x0000f800) == 0x0000f000 {
                                        return Opcode::BlH;
                                    }
                                }
                            }
                        } else {
                            if (code & 0x00004000) == 0x00004000 {
                                if (code & 0x00008000) == 0x00000000 {
                                    if (code & 0x0000f800) == 0x00007000 {
                                        return Opcode::StrbI;
                                    }
                                } else {
                                    if (code & 0x0000f800) == 0x0000f000 {
                                        return Opcode::BlH;
                                    }
                                }
                            } else {
                                if (code & 0x00008000) == 0x00000000 {
                                    if (code & 0x0000f800) == 0x00003000 {
                                        return Opcode::Add8;
                                    }
                                } else {
                                    if (code & 0x00000080) == 0x00000000 {
                                        if (code & 0x0000ff80) == 0x0000b000 {
                                            return Opcode::AddSp7;
                                        }
                                    } else {
                                        if (code & 0x0000ff80) == 0x0000b080 {
                                            return Opcode::SubSp7;
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if (code & 0x00000400) == 0x00000400 {
                        if (code & 0x00002000) == 0x00000000 {
                            if (code & 0x00004000) == 0x00000000 {
                                if (code & 0x00008000) == 0x00000000 {
                                    if (code & 0x0000f800) == 0x00001000 {
                                        return Opcode::AsrI;
                                    }
                                } else {
                                    if (code & 0x0000f800) == 0x00009000 {
                                        return Opcode::StrSp;
                                    }
                                }
                            } else {
                                if (code & 0x00008000) == 0x00000000 {
                                    if (code & 0x0000fe00) == 0x00005600 {
                                        return Opcode::Ldrsb;
                                    }
                                } else {
                                    if (code & 0x0000f000) == 0x0000d000 {
                                        return Opcode::B;
                                    }
                                }
                            }
                        } else {
                            if (code & 0x00004000) == 0x00004000 {
                                if (code & 0x00008000) == 0x00000000 {
                                    if (code & 0x0000f800) == 0x00007000 {
                                        return Opcode::StrbI;
                                    }
                                } else {
                                    if (code & 0x0000f800) == 0x0000f000 {
                                        return Opcode::BlH;
                                    }
                                }
                            } else {
                                if (code & 0x00008000) == 0x00000000 {
                                    if (code & 0x0000f800) == 0x00003000 {
                                        return Opcode::Add8;
                                    }
                                } else {
                                    if (code & 0x00000020) == 0x00000000 {
                                        #[cfg(any(feature = "v6k"))]
                                        if flags.version >= ArmVersion::V6K
                                            && (code & 0x0000fff7) == 0x0000b650
                                        {
                                            return Opcode::Setend;
                                        }
                                    } else {
                                        #[cfg(any(feature = "v6k"))]
                                        if flags.version >= ArmVersion::V6K
                                            && (code & 0x0000ffe8) == 0x0000b660
                                        {
                                            return Opcode::Cps;
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if (code & 0x00002000) == 0x00002000 {
                            if (code & 0x00000040) == 0x00000000 {
                                if (code & 0x00004000) == 0x00004000 {
                                    if (code & 0x00008000) == 0x00000000 {
                                        if (code & 0x0000f800) == 0x00007000 {
                                            return Opcode::StrbI;
                                        }
                                    } else {
                                        if (code & 0x0000f800) == 0x0000f000 {
                                            return Opcode::BlH;
                                        }
                                    }
                                } else {
                                    if (code & 0x00008000) == 0x00000000 {
                                        if (code & 0x0000f800) == 0x00003000 {
                                            return Opcode::Add8;
                                        }
                                    } else {
                                        if (code & 0x00000080) == 0x00000000 {
                                            #[cfg(any(feature = "v6k"))]
                                            if flags.version >= ArmVersion::V6K
                                                && (code & 0x0000ffc0) == 0x0000b200
                                            {
                                                return Opcode::Sxth;
                                            }
                                        } else {
                                            #[cfg(any(feature = "v6k"))]
                                            if flags.version >= ArmVersion::V6K
                                                && (code & 0x0000ffc0) == 0x0000b280
                                            {
                                                return Opcode::Uxth;
                                            }
                                        }
                                    }
                                }
                            } else {
                                if (code & 0x00004000) == 0x00004000 {
                                    if (code & 0x00008000) == 0x00000000 {
                                        if (code & 0x0000f800) == 0x00007000 {
                                            return Opcode::StrbI;
                                        }
                                    } else {
                                        if (code & 0x0000f800) == 0x0000f000 {
                                            return Opcode::BlH;
                                        }
                                    }
                                } else {
                                    if (code & 0x00008000) == 0x00000000 {
                                        if (code & 0x0000f800) == 0x00003000 {
                                            return Opcode::Add8;
                                        }
                                    } else {
                                        if (code & 0x00000080) == 0x00000000 {
                                            #[cfg(any(feature = "v6k"))]
                                            if flags.version >= ArmVersion::V6K
                                                && (code & 0x0000ffc0) == 0x0000b240
                                            {
                                                return Opcode::Sxtb;
                                            }
                                        } else {
                                            #[cfg(any(feature = "v6k"))]
                                            if flags.version >= ArmVersion::V6K
                                                && (code & 0x0000ffc0) == 0x0000b2c0
                                            {
                                                return Opcode::Uxtb;
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if (code & 0x00004000) == 0x00000000 {
                                if (code & 0x00008000) == 0x00000000 {
                                    if (code & 0x0000f800) == 0x00001000 {
                                        return Opcode::AsrI;
                                    }
                                } else {
                                    if (code & 0x0000f800) == 0x00009000 {
                                        return Opcode::StrSp;
                                    }
                                }
                            } else {
                                if (code & 0x00008000) == 0x00000000 {
                                    if (code & 0x0000fe00) == 0x00005200 {
                                        return Opcode::StrhR;
                                    }
                                } else {
                                    if (code & 0x0000f000) == 0x0000d000 {
                                        return Opcode::B;
                                    }
                                }
                            }
                        }
                    }
                }
            } else {
                if (code & 0x00004000) == 0x00004000 {
                    if (code & 0x00000200) == 0x00000000 {
                        if (code & 0x00002000) == 0x00002000 {
                            if (code & 0x00008000) == 0x00000000 {
                                if (code & 0x0000f800) == 0x00007800 {
                                    return Opcode::LdrbI;
                                }
                            } else {
                                if (code & 0x0000f800) == 0x0000f800 {
                                    return Opcode::Bl;
                                }
                            }
                        } else {
                            if (code & 0x00008000) == 0x00008000 {
                                if (code & 0x0000f000) == 0x0000d000 {
                                    return Opcode::B;
                                }
                            } else {
                                if (code & 0x00000400) == 0x00000000 {
                                    if (code & 0x0000fe00) == 0x00005800 {
                                        return Opcode::LdrR;
                                    }
                                } else {
                                    if (code & 0x0000fe00) == 0x00005c00 {
                                        return Opcode::LdrbR;
                                    }
                                }
                            }
                        }
                    } else {
                        if (code & 0x00000400) == 0x00000000 {
                            if (code & 0x00002000) == 0x00000000 {
                                if (code & 0x00008000) == 0x00000000 {
                                    if (code & 0x0000fe00) == 0x00005a00 {
                                        return Opcode::LdrhR;
                                    }
                                } else {
                                    if (code & 0x0000f000) == 0x0000d000 {
                                        return Opcode::B;
                                    }
                                }
                            } else {
                                if (code & 0x00008000) == 0x00000000 {
                                    if (code & 0x0000f800) == 0x00007800 {
                                        return Opcode::LdrbI;
                                    }
                                } else {
                                    if (code & 0x0000f800) == 0x0000f800 {
                                        return Opcode::Bl;
                                    }
                                }
                            }
                        } else {
                            if (code & 0x00000100) == 0x00000000 {
                                if (code & 0x00002000) == 0x00002000 {
                                    if (code & 0x00008000) == 0x00000000 {
                                        if (code & 0x0000f800) == 0x00007800 {
                                            return Opcode::LdrbI;
                                        }
                                    } else {
                                        if (code & 0x0000f800) == 0x0000f800 {
                                            return Opcode::Bl;
                                        }
                                    }
                                } else {
                                    if (code & 0x00008000) == 0x00000000 {
                                        if (code & 0x0000fe00) == 0x00005e00 {
                                            return Opcode::Ldrsh;
                                        }
                                    } else {
                                        #[cfg(any(feature = "v5te", feature = "v6k"))]
                                        if flags.version >= ArmVersion::V5Te
                                            && (code & 0x0000ff00) == 0x0000de00
                                        {
                                            return Opcode::Bkpt;
                                        }
                                        if (code & 0x0000f000) == 0x0000d000 {
                                            return Opcode::B;
                                        }
                                    }
                                }
                            } else {
                                if (code & 0x00002000) == 0x00000000 {
                                    if (code & 0x00008000) == 0x00008000 {
                                        if flags.ual && (code & 0x0000ff00) == 0x0000df00 {
                                            return Opcode::Svc;
                                        }
                                        if !flags.ual && (code & 0x0000ff00) == 0x0000df00 {
                                            return Opcode::Swi;
                                        }
                                        if (code & 0x0000f000) == 0x0000d000 {
                                            return Opcode::B;
                                        }
                                    } else {
                                        if (code & 0x0000fe00) == 0x00005e00 {
                                            return Opcode::Ldrsh;
                                        }
                                    }
                                } else {
                                    if (code & 0x00008000) == 0x00000000 {
                                        if (code & 0x0000f800) == 0x00007800 {
                                            return Opcode::LdrbI;
                                        }
                                    } else {
                                        if (code & 0x0000f800) == 0x0000f800 {
                                            return Opcode::Bl;
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if (code & 0x00002000) == 0x00002000 {
                        if (code & 0x00000200) == 0x00000000 {
                            if (code & 0x00008000) == 0x00000000 {
                                if (code & 0x0000f800) == 0x00003800 {
                                    return Opcode::Sub8;
                                }
                            } else {
                                if (code & 0x0000fe00) == 0x0000bc00 {
                                    return Opcode::Pop;
                                }
                            }
                        } else {
                            if (code & 0x00000040) == 0x00000000 {
                                if (code & 0x00008000) == 0x00000000 {
                                    if (code & 0x0000f800) == 0x00003800 {
                                        return Opcode::Sub8;
                                    }
                                } else {
                                    #[cfg(any(feature = "v6k"))]
                                    if flags.version >= ArmVersion::V6K
                                        && (code & 0x0000ffc0) == 0x0000ba00
                                    {
                                        return Opcode::Rev;
                                    }
                                }
                            } else {
                                if (code & 0x00008000) == 0x00000000 {
                                    if (code & 0x0000f800) == 0x00003800 {
                                        return Opcode::Sub8;
                                    }
                                } else {
                                    if (code & 0x00000080) == 0x00000000 {
                                        #[cfg(any(feature = "v6k"))]
                                        if flags.version >= ArmVersion::V6K
                                            && (code & 0x0000ffc0) == 0x0000ba40
                                        {
                                            return Opcode::Rev16;
                                        }
                                    } else {
                                        #[cfg(any(feature = "v6k"))]
                                        if flags.version >= ArmVersion::V6K
                                            && (code & 0x0000ffc0) == 0x0000bac0
                                        {
                                            return Opcode::Revsh;
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if (code & 0x00000200) == 0x00000200 {
                            if (code & 0x00008000) == 0x00008000 {
                                if (code & 0x0000f800) == 0x00009800 {
                                    return Opcode::LdrSp;
                                }
                            } else {
                                if (code & 0x00000400) == 0x00000000 {
                                    if (code & 0x0000fe00) == 0x00001a00 {
                                        return Opcode::SubR;
                                    }
                                } else {
                                    if (code & 0x0000fe00) == 0x00001e00 {
                                        return Opcode::Subs3;
                                    }
                                }
                            }
                        } else {
                            if (code & 0x00000400) == 0x00000000 {
                                if (code & 0x00008000) == 0x00000000 {
                                    if (code & 0x0000fe00) == 0x00001800 {
                                        return Opcode::AddR;
                                    }
                                } else {
                                    if (code & 0x0000f800) == 0x00009800 {
                                        return Opcode::LdrSp;
                                    }
                                }
                            } else {
                                if (code & 0x00008000) == 0x00008000 {
                                    if (code & 0x0000f800) == 0x00009800 {
                                        return Opcode::LdrSp;
                                    }
                                } else {
                                    if !flags.ual && (code & 0x0000ffc0) == 0x00001c00 {
                                        return Opcode::MovR;
                                    }
                                    if (code & 0x0000fe00) == 0x00001c00 {
                                        return Opcode::Add3;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        Opcode::Illegal
    }
    pub fn mnemonic(self) -> &'static str {
        OPCODE_MNEMONICS[self as usize]
    }
    pub fn count() -> usize {
        81
    }
}
impl Ins {
    /// Rd_0: Destination register
    #[inline(always)]
    pub fn field_rd_0(&self) -> Reg {
        Reg {
            deref: false,
            reg: Register::parse((self.code & 0x00000007)),
            writeback: false,
        }
    }
    /// Rd_0_ual: Destination register
    #[inline(always)]
    pub fn field_rd_0_ual(&self) -> Reg {
        Reg {
            deref: false,
            reg: Register::parse((self.code & 0x00000007)),
            writeback: false,
        }
    }
    /// Rd_8: Destination register
    #[inline(always)]
    pub fn field_rd_8(&self) -> Reg {
        Reg {
            deref: false,
            reg: Register::parse(((self.code >> 8) & 0x00000007)),
            writeback: false,
        }
    }
    /// Rd_H1: Destination register
    #[inline(always)]
    pub fn field_rd_h1(&self) -> Reg {
        Reg {
            deref: false,
            reg: Register::parse(
                (self.code & 0x00000007) | ((self.code >> 7) & 0x00000001) << 3,
            ),
            writeback: false,
        }
    }
    /// Rd_H1_ual: Destination register
    #[inline(always)]
    pub fn field_rd_h1_ual(&self) -> Reg {
        Reg {
            deref: false,
            reg: Register::parse(
                (self.code & 0x00000007) | ((self.code >> 7) & 0x00000001) << 3,
            ),
            writeback: false,
        }
    }
    /// Rn_0: First source operand register
    #[inline(always)]
    pub fn field_rn_0(&self) -> Reg {
        Reg {
            deref: false,
            reg: Register::parse((self.code & 0x00000007)),
            writeback: false,
        }
    }
    /// Rn_3: First source operand register
    #[inline(always)]
    pub fn field_rn_3(&self) -> Reg {
        Reg {
            deref: false,
            reg: Register::parse(((self.code >> 3) & 0x00000007)),
            writeback: false,
        }
    }
    /// Rn_3_deref: Base register
    #[inline(always)]
    pub fn field_rn_3_deref(&self) -> Reg {
        Reg {
            deref: true,
            reg: Register::parse(((self.code >> 3) & 0x00000007)),
            writeback: false,
        }
    }
    /// Rn_8: First source operand register
    #[inline(always)]
    pub fn field_rn_8(&self) -> Reg {
        Reg {
            deref: false,
            reg: Register::parse(((self.code >> 8) & 0x00000007)),
            writeback: false,
        }
    }
    /// Rn_8_wb: First source operand register
    #[inline(always)]
    pub fn field_rn_8_wb(&self) -> Reg {
        Reg {
            deref: false,
            reg: Register::parse(((self.code >> 8) & 0x00000007)),
            writeback: true,
        }
    }
    /// Rn_8_ldm: First source operand register
    #[inline(always)]
    pub fn field_rn_8_ldm(&self) -> Reg {
        Reg {
            deref: false,
            reg: Register::parse(((self.code >> 8) & 0x00000007)),
            writeback: (!(self.code & 0x000000ff)
                & (1 << ((self.code >> 8) & 0x00000007))) != 0,
        }
    }
    /// Rn_H1: First source operand register
    #[inline(always)]
    pub fn field_rn_h1(&self) -> Reg {
        Reg {
            deref: false,
            reg: Register::parse(
                (self.code & 0x00000007) | ((self.code >> 7) & 0x00000001) << 3,
            ),
            writeback: false,
        }
    }
    /// Rm_3: Second source operand register
    #[inline(always)]
    pub fn field_rm_3(&self) -> Reg {
        Reg {
            deref: false,
            reg: Register::parse(((self.code >> 3) & 0x00000007)),
            writeback: false,
        }
    }
    /// Rm_6: Second source operand register
    #[inline(always)]
    pub fn field_rm_6(&self) -> Reg {
        Reg {
            deref: false,
            reg: Register::parse(((self.code >> 6) & 0x00000007)),
            writeback: false,
        }
    }
    /// Rm_6_offset: Offset register
    #[inline(always)]
    pub fn field_rm_6_offset(&self) -> OffsetReg {
        OffsetReg {
            add: true,
            post_indexed: false,
            reg: Register::parse(((self.code >> 6) & 0x00000007)),
        }
    }
    /// Rm_H2: Second source operand register
    #[inline(always)]
    pub fn field_rm_h2(&self) -> Reg {
        Reg {
            deref: false,
            reg: Register::parse(((self.code >> 3) & 0x0000000f)),
            writeback: false,
        }
    }
    /// Rs: Register containing shift offset
    #[inline(always)]
    pub fn field_rs(&self) -> Reg {
        Reg {
            deref: false,
            reg: Register::parse(((self.code >> 3) & 0x00000007)),
            writeback: false,
        }
    }
    /// pc: Program counter
    #[inline(always)]
    pub fn field_pc(&self) -> Reg {
        Reg {
            deref: false,
            reg: Register::parse(15),
            writeback: false,
        }
    }
    /// pc_deref: Program counter as base register
    #[inline(always)]
    pub fn field_pc_deref(&self) -> Reg {
        Reg {
            deref: true,
            reg: Register::parse(15),
            writeback: false,
        }
    }
    /// sp: Stack pointer
    #[inline(always)]
    pub fn field_sp(&self) -> Reg {
        Reg {
            deref: false,
            reg: Register::parse(13),
            writeback: false,
        }
    }
    /// sp_ual: Stack pointer
    #[inline(always)]
    pub fn field_sp_ual(&self) -> Reg {
        Reg {
            deref: false,
            reg: Register::parse(13),
            writeback: false,
        }
    }
    /// sp_deref: Stack pointer as base register
    #[inline(always)]
    pub fn field_sp_deref(&self) -> Reg {
        Reg {
            deref: true,
            reg: Register::parse(13),
            writeback: false,
        }
    }
    /// registers: List of general-purpose registers
    #[inline(always)]
    pub fn field_registers(&self) -> RegList {
        RegList {
            regs: (self.code & 0x000000ff),
            user_mode: false,
        }
    }
    /// registers_pc: List of general-purpose registers, including PC
    #[inline(always)]
    pub fn field_registers_pc(&self) -> RegList {
        RegList {
            regs: (self.code & 0x000000ff) | ((self.code >> 8) & 0x00000001) << 15,
            user_mode: false,
        }
    }
    /// registers_lr: List of general-purpose registers, including LR
    #[inline(always)]
    pub fn field_registers_lr(&self) -> RegList {
        RegList {
            regs: (self.code & 0x000000ff) | ((self.code >> 8) & 0x00000001) << 14,
            user_mode: false,
        }
    }
    /// zero: Zero
    #[inline(always)]
    pub fn field_zero(&self) -> u32 {
        0
    }
    /// immed_3: 3-bit immediate
    #[inline(always)]
    pub fn field_immed_3(&self) -> u32 {
        ((self.code >> 6) & 0x00000007)
    }
    /// immed_8: 8-bit immediate
    #[inline(always)]
    pub fn field_immed_8(&self) -> u32 {
        (self.code & 0x000000ff)
    }
    /// rel_immed_7: Address-relative 7-bit immediate
    #[inline(always)]
    pub fn field_rel_immed_7(&self) -> u32 {
        (self.code & 0x0000007f) << 2
    }
    /// rel_immed_8: Address-relative 8-bit immediate
    #[inline(always)]
    pub fn field_rel_immed_8(&self) -> u32 {
        (self.code & 0x000000ff) << 2
    }
    /// left_shift_imm: 5-bit left shift offset
    #[inline(always)]
    pub fn field_left_shift_imm(&self) -> u32 {
        ((self.code >> 6) & 0x0000001f)
    }
    /// right_shift_imm: 5-bit right shift offset
    #[inline(always)]
    pub fn field_right_shift_imm(&self) -> u32 {
        {
            let value = ((self.code >> 6) & 0x0000001f);
            match 1 {
                1 | 2 => if value == 0 { 32 } else { value }
                _ => value,
            }
        }
    }
    /// branch_offset_8: 9-bit signed B target offset
    #[inline(always)]
    pub fn field_branch_offset_8(&self) -> i32 {
        (((self.code & 0x000000ff) << 1) + 4) as i32
    }
    /// branch_offset_11: 12-bit signed B target offset
    #[inline(always)]
    pub fn field_branch_offset_11(&self) -> i32 {
        (((self.code & 0x000007ff) << 1) + 4) as i32
    }
    /// high_branch_offset_11: 23-bit signed BL/BLX target offset (high part)
    #[inline(always)]
    pub fn field_high_branch_offset_11(&self) -> i32 {
        (((self.code & 0x000007ff) << 12) + 4) as i32
    }
    /// low_branch_offset_11: 23-bit signed BL target offset (low part)
    #[inline(always)]
    pub fn field_low_branch_offset_11(&self) -> u32 {
        (self.code & 0x000007ff) << 1
    }
    /// low_blx_offset_11: 23-bit signed BLX target offset (low part)
    #[inline(always)]
    pub fn field_low_blx_offset_11(&self) -> u32 {
        (self.code & 0x000007ff) << 1 & !3
    }
    /// offset_5: 7-bit immediate offset
    #[inline(always)]
    pub fn field_offset_5(&self) -> OffsetImm {
        OffsetImm {
            post_indexed: false,
            value: (((self.code >> 6) & 0x0000001f) << 2) as i32,
        }
    }
    /// cpsr_flags: CPSR flags
    #[inline(always)]
    pub fn field_cpsr_flags(&self) -> CpsrFlags {
        CpsrFlags {
            a: (((self.code >> 2) & 0x00000001)) != 0,
            enable: (((self.code >> 4) & 0x00000001)) != 0,
            f: ((self.code & 0x00000001)) != 0,
            i: (((self.code >> 1) & 0x00000001)) != 0,
        }
    }
    /// endian: Endian specifier
    #[inline(always)]
    pub fn field_endian(&self) -> Endian {
        Endian::parse(((self.code >> 3) & 0x00000001))
    }
    /// imod: Modify interrupt flags
    #[inline(always)]
    pub const fn modifier_imod(&self) -> Imod {
        match self.code & 0x00000010 {
            0x00000000 => Imod::Ie,
            0x00000010 => Imod::Id,
            _ => Imod::Illegal,
        }
    }
    /// cond: Condition code
    #[inline(always)]
    pub const fn modifier_cond(&self) -> Cond {
        match self.code & 0x00000f00 {
            0x00000000 => Cond::Eq,
            0x00000100 => Cond::Ne,
            0x00000200 => Cond::Hs,
            0x00000300 => Cond::Lo,
            0x00000400 => Cond::Mi,
            0x00000500 => Cond::Pl,
            0x00000600 => Cond::Vs,
            0x00000700 => Cond::Vc,
            0x00000800 => Cond::Hi,
            0x00000900 => Cond::Ls,
            0x00000a00 => Cond::Ge,
            0x00000b00 => Cond::Lt,
            0x00000c00 => Cond::Gt,
            0x00000d00 => Cond::Le,
            0x00000e00 => Cond::Al,
            _ => Cond::Illegal,
        }
    }
    /// imod: Modify interrupt flags
    pub fn has_imod(&self) -> bool {
        matches!(self.op, Opcode::Cps)
    }
    /// cond: Condition code
    pub fn has_cond(&self) -> bool {
        matches!(self.op, Opcode::B)
    }
    /// This opcode loads multiple values from memory into registers.
    pub fn loads_multiple(&self) -> bool {
        matches!(self.op, Opcode::Ldm | Opcode::Ldmia | Opcode::Pop)
    }
}
/// imod: Modify interrupt flags
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Imod {
    Illegal,
    /// ie: Interrupt Enable
    Ie,
    /// id: Interrupt Disable
    Id,
}
/// cond: Condition code
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Cond {
    Illegal,
    /// eq: Equal
    Eq,
    /// ne: Not equal
    Ne,
    /// hs: Unsigned higher or same
    Hs,
    /// lo: Unsigned lower
    Lo,
    /// mi: Minus/negative
    Mi,
    /// pl: Plus/positive or zero
    Pl,
    /// vs: Overflow
    Vs,
    /// vc: No overflow
    Vc,
    /// hi: Unsigned higher
    Hi,
    /// ls: Unsigned lower or same
    Ls,
    /// ge: Signed greater than or equal
    Ge,
    /// lt: Signed less than
    Lt,
    /// gt: Signed greater than
    Gt,
    /// le: Signed less than or equal
    Le,
    /// al: Always
    Al,
}
fn parse_adc(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    if flags.ual {
        *out = ParsedIns {
            mnemonic: "adcs",
            args: [
                Argument::Reg(ins.field_rd_0()),
                Argument::Reg(ins.field_rd_0_ual()),
                Argument::Reg(ins.field_rm_3()),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    } else {
        *out = ParsedIns {
            mnemonic: "adc",
            args: [
                Argument::Reg(ins.field_rd_0()),
                Argument::Reg(ins.field_rm_3()),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    }
}
fn parse_add_3(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    if flags.ual {
        *out = ParsedIns {
            mnemonic: "adds",
            args: [
                Argument::Reg(ins.field_rd_0()),
                Argument::Reg(ins.field_rn_3()),
                Argument::UImm(ins.field_immed_3()),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    } else {
        *out = ParsedIns {
            mnemonic: "add",
            args: [
                Argument::Reg(ins.field_rd_0()),
                Argument::Reg(ins.field_rn_3()),
                Argument::UImm(ins.field_immed_3()),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    }
}
fn parse_add_8(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    if flags.ual {
        *out = ParsedIns {
            mnemonic: "adds",
            args: [
                Argument::Reg(ins.field_rd_8()),
                Argument::UImm(ins.field_immed_8()),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    } else {
        *out = ParsedIns {
            mnemonic: "add",
            args: [
                Argument::Reg(ins.field_rd_8()),
                Argument::UImm(ins.field_immed_8()),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    }
}
fn parse_add_r(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    if flags.ual {
        *out = ParsedIns {
            mnemonic: "adds",
            args: [
                Argument::Reg(ins.field_rd_0()),
                Argument::Reg(ins.field_rn_3()),
                Argument::Reg(ins.field_rm_6()),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    } else {
        *out = ParsedIns {
            mnemonic: "add",
            args: [
                Argument::Reg(ins.field_rd_0()),
                Argument::Reg(ins.field_rn_3()),
                Argument::Reg(ins.field_rm_6()),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    }
}
fn parse_add_hr(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    if flags.ual {
        *out = ParsedIns {
            mnemonic: "add",
            args: [
                Argument::Reg(ins.field_rd_h1()),
                Argument::Reg(ins.field_rd_h1_ual()),
                Argument::Reg(ins.field_rm_h2()),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    } else {
        *out = ParsedIns {
            mnemonic: "add",
            args: [
                Argument::Reg(ins.field_rd_h1()),
                Argument::Reg(ins.field_rm_h2()),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    }
}
fn parse_add_sp(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "add",
        args: [
            Argument::Reg(ins.field_rd_8()),
            Argument::Reg(ins.field_sp()),
            Argument::UImm(ins.field_rel_immed_8()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_add_sp7(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    if flags.ual {
        *out = ParsedIns {
            mnemonic: "add",
            args: [
                Argument::Reg(ins.field_sp()),
                Argument::Reg(ins.field_sp_ual()),
                Argument::UImm(ins.field_rel_immed_7()),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    } else {
        *out = ParsedIns {
            mnemonic: "add",
            args: [
                Argument::Reg(ins.field_sp()),
                Argument::UImm(ins.field_rel_immed_7()),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    }
}
fn parse_add_reg_sp(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "add",
        args: [
            Argument::Reg(ins.field_rd_h1()),
            Argument::Reg(ins.field_sp()),
            Argument::Reg(ins.field_rd_h1()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_add_sp_reg(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    if flags.ual {
        *out = ParsedIns {
            mnemonic: "add",
            args: [
                Argument::Reg(ins.field_sp()),
                Argument::Reg(ins.field_sp_ual()),
                Argument::Reg(ins.field_rm_h2()),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    } else {
        *out = ParsedIns {
            mnemonic: "add",
            args: [
                Argument::Reg(ins.field_sp()),
                Argument::Reg(ins.field_rm_h2()),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    }
}
fn parse_add_pc(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "add",
        args: [
            Argument::Reg(ins.field_rd_8()),
            Argument::Reg(ins.field_pc()),
            Argument::UImm(ins.field_rel_immed_8()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_adr(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "adr",
        args: [
            Argument::Reg(ins.field_rd_8()),
            Argument::UImm(ins.field_rel_immed_8()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_and(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    if flags.ual {
        *out = ParsedIns {
            mnemonic: "ands",
            args: [
                Argument::Reg(ins.field_rd_0()),
                Argument::Reg(ins.field_rd_0_ual()),
                Argument::Reg(ins.field_rm_3()),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    } else {
        *out = ParsedIns {
            mnemonic: "and",
            args: [
                Argument::Reg(ins.field_rd_0()),
                Argument::Reg(ins.field_rm_3()),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    }
}
fn parse_asr_i(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    if flags.ual {
        *out = ParsedIns {
            mnemonic: "asrs",
            args: [
                Argument::Reg(ins.field_rd_0()),
                Argument::Reg(ins.field_rm_3()),
                Argument::UImm(ins.field_right_shift_imm()),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    } else {
        *out = ParsedIns {
            mnemonic: "asr",
            args: [
                Argument::Reg(ins.field_rd_0()),
                Argument::Reg(ins.field_rm_3()),
                Argument::UImm(ins.field_right_shift_imm()),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    }
}
fn parse_asr_r(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    if flags.ual {
        *out = ParsedIns {
            mnemonic: "asrs",
            args: [
                Argument::Reg(ins.field_rd_0()),
                Argument::Reg(ins.field_rd_0_ual()),
                Argument::Reg(ins.field_rs()),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    } else {
        *out = ParsedIns {
            mnemonic: "asr",
            args: [
                Argument::Reg(ins.field_rd_0()),
                Argument::Reg(ins.field_rs()),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    }
}
fn parse_b(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = match ins.modifier_cond() {
        Cond::Eq => {
            ParsedIns {
                mnemonic: "beq",
                args: [
                    Argument::BranchDest(ins.field_branch_offset_8()),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        }
        Cond::Ne => {
            ParsedIns {
                mnemonic: "bne",
                args: [
                    Argument::BranchDest(ins.field_branch_offset_8()),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        }
        Cond::Hs => {
            ParsedIns {
                mnemonic: "bhs",
                args: [
                    Argument::BranchDest(ins.field_branch_offset_8()),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        }
        Cond::Lo => {
            ParsedIns {
                mnemonic: "blo",
                args: [
                    Argument::BranchDest(ins.field_branch_offset_8()),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        }
        Cond::Mi => {
            ParsedIns {
                mnemonic: "bmi",
                args: [
                    Argument::BranchDest(ins.field_branch_offset_8()),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        }
        Cond::Pl => {
            ParsedIns {
                mnemonic: "bpl",
                args: [
                    Argument::BranchDest(ins.field_branch_offset_8()),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        }
        Cond::Vs => {
            ParsedIns {
                mnemonic: "bvs",
                args: [
                    Argument::BranchDest(ins.field_branch_offset_8()),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        }
        Cond::Vc => {
            ParsedIns {
                mnemonic: "bvc",
                args: [
                    Argument::BranchDest(ins.field_branch_offset_8()),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        }
        Cond::Hi => {
            ParsedIns {
                mnemonic: "bhi",
                args: [
                    Argument::BranchDest(ins.field_branch_offset_8()),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        }
        Cond::Ls => {
            ParsedIns {
                mnemonic: "bls",
                args: [
                    Argument::BranchDest(ins.field_branch_offset_8()),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        }
        Cond::Ge => {
            ParsedIns {
                mnemonic: "bge",
                args: [
                    Argument::BranchDest(ins.field_branch_offset_8()),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        }
        Cond::Lt => {
            ParsedIns {
                mnemonic: "blt",
                args: [
                    Argument::BranchDest(ins.field_branch_offset_8()),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        }
        Cond::Gt => {
            ParsedIns {
                mnemonic: "bgt",
                args: [
                    Argument::BranchDest(ins.field_branch_offset_8()),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        }
        Cond::Le => {
            ParsedIns {
                mnemonic: "ble",
                args: [
                    Argument::BranchDest(ins.field_branch_offset_8()),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        }
        Cond::Al => {
            ParsedIns {
                mnemonic: "b",
                args: [
                    Argument::BranchDest(ins.field_branch_offset_8()),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        }
        _ => {
            ParsedIns {
                mnemonic: "<illegal>",
                args: [
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        }
    };
}
fn parse_b_long(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "b",
        args: [
            Argument::SImm(ins.field_branch_offset_11()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_bic(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    if flags.ual {
        *out = ParsedIns {
            mnemonic: "bics",
            args: [
                Argument::Reg(ins.field_rd_0()),
                Argument::Reg(ins.field_rd_0_ual()),
                Argument::Reg(ins.field_rm_3()),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    } else {
        *out = ParsedIns {
            mnemonic: "bic",
            args: [
                Argument::Reg(ins.field_rd_0()),
                Argument::Reg(ins.field_rm_3()),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    }
}
fn parse_bkpt(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "bkpt",
        args: [
            Argument::UImm(ins.field_immed_8()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_bl_h(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "bl",
        args: [
            Argument::SImm(ins.field_high_branch_offset_11()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_bl(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "bl",
        args: [
            Argument::UImm(ins.field_low_branch_offset_11()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_blx_i(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "blx",
        args: [
            Argument::UImm(ins.field_low_blx_offset_11()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_blx_r(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "blx",
        args: [
            Argument::Reg(ins.field_rm_h2()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_bx_r(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "bx",
        args: [
            Argument::Reg(ins.field_rm_h2()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_cmn(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "cmn",
        args: [
            Argument::Reg(ins.field_rn_0()),
            Argument::Reg(ins.field_rm_3()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_cmp_i(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "cmp",
        args: [
            Argument::Reg(ins.field_rn_8()),
            Argument::UImm(ins.field_immed_8()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_cmp_r(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "cmp",
        args: [
            Argument::Reg(ins.field_rn_0()),
            Argument::Reg(ins.field_rm_3()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_cmp_hr(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "cmp",
        args: [
            Argument::Reg(ins.field_rn_h1()),
            Argument::Reg(ins.field_rm_h2()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_cps(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = match ins.modifier_imod() {
        Imod::Ie => {
            ParsedIns {
                mnemonic: "cpsie",
                args: [
                    Argument::CpsrFlags(ins.field_cpsr_flags()),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        }
        Imod::Id => {
            ParsedIns {
                mnemonic: "cpsid",
                args: [
                    Argument::CpsrFlags(ins.field_cpsr_flags()),
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        }
        _ => {
            ParsedIns {
                mnemonic: "<illegal>",
                args: [
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                    Argument::None,
                ],
            }
        }
    };
}
fn parse_eor(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    if flags.ual {
        *out = ParsedIns {
            mnemonic: "eors",
            args: [
                Argument::Reg(ins.field_rd_0()),
                Argument::Reg(ins.field_rd_0_ual()),
                Argument::Reg(ins.field_rm_3()),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    } else {
        *out = ParsedIns {
            mnemonic: "eor",
            args: [
                Argument::Reg(ins.field_rd_0()),
                Argument::Reg(ins.field_rm_3()),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    }
}
fn parse_ldm(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "ldm",
        args: [
            Argument::Reg(ins.field_rn_8_ldm()),
            Argument::RegList(ins.field_registers()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_ldmia(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "ldmia",
        args: [
            Argument::Reg(ins.field_rn_8_wb()),
            Argument::RegList(ins.field_registers()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_ldr_i(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "ldr",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rn_3_deref()),
            Argument::OffsetImm(ins.field_offset_5()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_ldr_r(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "ldr",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rn_3_deref()),
            Argument::OffsetReg(ins.field_rm_6_offset()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_ldr_pc(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "ldr",
        args: [
            Argument::Reg(ins.field_rd_8()),
            Argument::Reg(ins.field_pc_deref()),
            Argument::UImm(ins.field_rel_immed_8()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_ldr_sp(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "ldr",
        args: [
            Argument::Reg(ins.field_rd_8()),
            Argument::Reg(ins.field_sp_deref()),
            Argument::UImm(ins.field_rel_immed_8()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_ldrb_i(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "ldrb",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rn_3_deref()),
            Argument::OffsetImm(ins.field_offset_5()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_ldrb_r(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "ldrb",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rn_3_deref()),
            Argument::OffsetReg(ins.field_rm_6_offset()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_ldrh_i(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "ldrh",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rn_3_deref()),
            Argument::OffsetImm(ins.field_offset_5()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_ldrh_r(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "ldrh",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rn_3_deref()),
            Argument::OffsetReg(ins.field_rm_6_offset()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_ldrsb(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "ldrsb",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rn_3_deref()),
            Argument::OffsetReg(ins.field_rm_6_offset()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_ldrsh(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "ldrsh",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rn_3_deref()),
            Argument::OffsetReg(ins.field_rm_6_offset()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_lsl_i(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    if flags.ual {
        *out = ParsedIns {
            mnemonic: "lsls",
            args: [
                Argument::Reg(ins.field_rd_0()),
                Argument::Reg(ins.field_rm_3()),
                Argument::UImm(ins.field_left_shift_imm()),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    } else {
        *out = ParsedIns {
            mnemonic: "lsl",
            args: [
                Argument::Reg(ins.field_rd_0()),
                Argument::Reg(ins.field_rm_3()),
                Argument::UImm(ins.field_left_shift_imm()),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    }
}
fn parse_lsl_r(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    if flags.ual {
        *out = ParsedIns {
            mnemonic: "lsls",
            args: [
                Argument::Reg(ins.field_rd_0()),
                Argument::Reg(ins.field_rd_0_ual()),
                Argument::Reg(ins.field_rs()),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    } else {
        *out = ParsedIns {
            mnemonic: "lsl",
            args: [
                Argument::Reg(ins.field_rd_0()),
                Argument::Reg(ins.field_rs()),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    }
}
fn parse_lsr_i(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    if flags.ual {
        *out = ParsedIns {
            mnemonic: "lsrs",
            args: [
                Argument::Reg(ins.field_rd_0()),
                Argument::Reg(ins.field_rm_3()),
                Argument::UImm(ins.field_right_shift_imm()),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    } else {
        *out = ParsedIns {
            mnemonic: "lsr",
            args: [
                Argument::Reg(ins.field_rd_0()),
                Argument::Reg(ins.field_rm_3()),
                Argument::UImm(ins.field_right_shift_imm()),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    }
}
fn parse_lsr_r(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    if flags.ual {
        *out = ParsedIns {
            mnemonic: "lsrs",
            args: [
                Argument::Reg(ins.field_rd_0()),
                Argument::Reg(ins.field_rd_0_ual()),
                Argument::Reg(ins.field_rs()),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    } else {
        *out = ParsedIns {
            mnemonic: "lsr",
            args: [
                Argument::Reg(ins.field_rd_0()),
                Argument::Reg(ins.field_rs()),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    }
}
fn parse_mov_i(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    if flags.ual {
        *out = ParsedIns {
            mnemonic: "movs",
            args: [
                Argument::Reg(ins.field_rd_8()),
                Argument::UImm(ins.field_immed_8()),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    } else {
        *out = ParsedIns {
            mnemonic: "mov",
            args: [
                Argument::Reg(ins.field_rd_8()),
                Argument::UImm(ins.field_immed_8()),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    }
}
fn parse_mov_r(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "mov",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rn_3()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_movs_r(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "movs",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rn_3()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_mov_hr(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "mov",
        args: [
            Argument::Reg(ins.field_rd_h1()),
            Argument::Reg(ins.field_rm_h2()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_mul(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    if flags.ual {
        *out = ParsedIns {
            mnemonic: "muls",
            args: [
                Argument::Reg(ins.field_rd_0()),
                Argument::Reg(ins.field_rd_0_ual()),
                Argument::Reg(ins.field_rm_3()),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    } else {
        *out = ParsedIns {
            mnemonic: "mul",
            args: [
                Argument::Reg(ins.field_rd_0()),
                Argument::Reg(ins.field_rm_3()),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    }
}
fn parse_mvn(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    if flags.ual {
        *out = ParsedIns {
            mnemonic: "mvns",
            args: [
                Argument::Reg(ins.field_rd_0()),
                Argument::Reg(ins.field_rm_3()),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    } else {
        *out = ParsedIns {
            mnemonic: "mvn",
            args: [
                Argument::Reg(ins.field_rd_0()),
                Argument::Reg(ins.field_rm_3()),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    }
}
fn parse_neg(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "neg",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rm_3()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_rsbs(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "rsbs",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rm_3()),
            Argument::UImm(ins.field_zero()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_orr(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    if flags.ual {
        *out = ParsedIns {
            mnemonic: "orrs",
            args: [
                Argument::Reg(ins.field_rd_0()),
                Argument::Reg(ins.field_rd_0_ual()),
                Argument::Reg(ins.field_rm_3()),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    } else {
        *out = ParsedIns {
            mnemonic: "orr",
            args: [
                Argument::Reg(ins.field_rd_0()),
                Argument::Reg(ins.field_rm_3()),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    }
}
fn parse_pop(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "pop",
        args: [
            Argument::RegList(ins.field_registers_pc()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_push(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "push",
        args: [
            Argument::RegList(ins.field_registers_lr()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_rev(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "rev",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rn_3()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_rev16(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "rev16",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rn_3()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_revsh(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "revsh",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rn_3()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_ror(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    if flags.ual {
        *out = ParsedIns {
            mnemonic: "rors",
            args: [
                Argument::Reg(ins.field_rd_0()),
                Argument::Reg(ins.field_rd_0_ual()),
                Argument::Reg(ins.field_rs()),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    } else {
        *out = ParsedIns {
            mnemonic: "ror",
            args: [
                Argument::Reg(ins.field_rd_0()),
                Argument::Reg(ins.field_rs()),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    }
}
fn parse_sbc(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    if flags.ual {
        *out = ParsedIns {
            mnemonic: "sbcs",
            args: [
                Argument::Reg(ins.field_rd_0()),
                Argument::Reg(ins.field_rd_0_ual()),
                Argument::Reg(ins.field_rm_3()),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    } else {
        *out = ParsedIns {
            mnemonic: "sbc",
            args: [
                Argument::Reg(ins.field_rd_0()),
                Argument::Reg(ins.field_rm_3()),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    }
}
fn parse_setend(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "setend",
        args: [
            Argument::Endian(ins.field_endian()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_stm(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    if flags.ual {
        *out = ParsedIns {
            mnemonic: "stm",
            args: [
                Argument::Reg(ins.field_rn_8_wb()),
                Argument::RegList(ins.field_registers()),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    } else {
        *out = ParsedIns {
            mnemonic: "stmia",
            args: [
                Argument::Reg(ins.field_rn_8_wb()),
                Argument::RegList(ins.field_registers()),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    }
}
fn parse_str_i(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "str",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rn_3_deref()),
            Argument::OffsetImm(ins.field_offset_5()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_str_r(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "str",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rn_3_deref()),
            Argument::OffsetReg(ins.field_rm_6_offset()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_str_sp(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "str",
        args: [
            Argument::Reg(ins.field_rd_8()),
            Argument::Reg(ins.field_sp_deref()),
            Argument::UImm(ins.field_rel_immed_8()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_strb_i(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "strb",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rn_3_deref()),
            Argument::OffsetImm(ins.field_offset_5()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_strb_r(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "strb",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rn_3_deref()),
            Argument::OffsetReg(ins.field_rm_6_offset()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_strh_i(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "strh",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rn_3_deref()),
            Argument::OffsetImm(ins.field_offset_5()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_strh_r(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "strh",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rn_3_deref()),
            Argument::OffsetReg(ins.field_rm_6_offset()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_subs_3(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "subs",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rn_3()),
            Argument::UImm(ins.field_immed_3()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_sub_8(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    if flags.ual {
        *out = ParsedIns {
            mnemonic: "subs",
            args: [
                Argument::Reg(ins.field_rd_8()),
                Argument::UImm(ins.field_immed_8()),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    } else {
        *out = ParsedIns {
            mnemonic: "sub",
            args: [
                Argument::Reg(ins.field_rd_8()),
                Argument::UImm(ins.field_immed_8()),
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    }
}
fn parse_sub_r(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    if flags.ual {
        *out = ParsedIns {
            mnemonic: "subs",
            args: [
                Argument::Reg(ins.field_rd_0()),
                Argument::Reg(ins.field_rn_3()),
                Argument::Reg(ins.field_rm_6()),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    } else {
        *out = ParsedIns {
            mnemonic: "sub",
            args: [
                Argument::Reg(ins.field_rd_0()),
                Argument::Reg(ins.field_rn_3()),
                Argument::Reg(ins.field_rm_6()),
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        }
    }
}
fn parse_sub_sp7(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "sub",
        args: [
            Argument::Reg(ins.field_sp()),
            Argument::Reg(ins.field_sp()),
            Argument::UImm(ins.field_rel_immed_7()),
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_svc(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "svc",
        args: [
            Argument::UImm(ins.field_immed_8()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_swi(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "swi",
        args: [
            Argument::UImm(ins.field_immed_8()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_sxtb(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "sxtb",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rm_3()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_sxth(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "sxth",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rm_3()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_tst(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "tst",
        args: [
            Argument::Reg(ins.field_rn_0()),
            Argument::Reg(ins.field_rm_3()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_uxtb(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "uxtb",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rm_3()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
fn parse_uxth(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    *out = ParsedIns {
        mnemonic: "uxth",
        args: [
            Argument::Reg(ins.field_rd_0()),
            Argument::Reg(ins.field_rm_3()),
            Argument::None,
            Argument::None,
            Argument::None,
            Argument::None,
        ],
    };
}
type MnemonicParser = fn(&mut ParsedIns, Ins, &ParseFlags);
static MNEMONIC_PARSERS: [MnemonicParser; 81] = [
    parse_adc,
    parse_add_3,
    parse_add_8,
    parse_add_r,
    parse_add_hr,
    parse_add_sp,
    parse_add_sp7,
    parse_add_reg_sp,
    parse_add_sp_reg,
    parse_add_pc,
    parse_adr,
    parse_and,
    parse_asr_i,
    parse_asr_r,
    parse_b,
    parse_b_long,
    parse_bic,
    parse_bkpt,
    parse_bl_h,
    parse_bl,
    parse_blx_i,
    parse_blx_r,
    parse_bx_r,
    parse_cmn,
    parse_cmp_i,
    parse_cmp_r,
    parse_cmp_hr,
    parse_cps,
    parse_eor,
    parse_ldm,
    parse_ldmia,
    parse_ldr_i,
    parse_ldr_r,
    parse_ldr_pc,
    parse_ldr_sp,
    parse_ldrb_i,
    parse_ldrb_r,
    parse_ldrh_i,
    parse_ldrh_r,
    parse_ldrsb,
    parse_ldrsh,
    parse_lsl_i,
    parse_lsl_r,
    parse_lsr_i,
    parse_lsr_r,
    parse_mov_i,
    parse_mov_r,
    parse_movs_r,
    parse_mov_hr,
    parse_mul,
    parse_mvn,
    parse_neg,
    parse_rsbs,
    parse_orr,
    parse_pop,
    parse_push,
    parse_rev,
    parse_rev16,
    parse_revsh,
    parse_ror,
    parse_sbc,
    parse_setend,
    parse_stm,
    parse_str_i,
    parse_str_r,
    parse_str_sp,
    parse_strb_i,
    parse_strb_r,
    parse_strh_i,
    parse_strh_r,
    parse_subs_3,
    parse_sub_8,
    parse_sub_r,
    parse_sub_sp7,
    parse_svc,
    parse_swi,
    parse_sxtb,
    parse_sxth,
    parse_tst,
    parse_uxtb,
    parse_uxth,
];
#[inline]
pub fn parse(out: &mut ParsedIns, ins: Ins, flags: &ParseFlags) {
    if ins.op != Opcode::Illegal {
        MNEMONIC_PARSERS[ins.op as usize](out, ins, flags);
    } else {
        *out = ParsedIns {
            mnemonic: "<illegal>",
            args: [
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
                Argument::None,
            ],
        };
    }
}
