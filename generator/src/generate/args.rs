use std::collections::BTreeMap;

use anyhow::Result;
use proc_macro2::{Literal, Span, TokenStream};
use quote::quote;
use syn::Ident;

use crate::args::{is_continuous, ArgType, EnumValue, IsaArgs, StructMember, TypeKind};

pub fn generate_args(isa_args: &IsaArgs, max_args: usize) -> Result<TokenStream> {
    let types = generate_types(isa_args)?;
    let arg_types = generate_arg_types(isa_args)?;
    let args_enum = generate_args_enum(isa_args, max_args)?;

    Ok(quote! {
        #![cfg_attr(rustfmt, rustfmt_skip)]
        #![allow(unused)]
        #[comment = " Generated by unarm-generator. Do not edit!"]

        #args_enum
        #(#types)*
        #(#arg_types)*
    })
}

fn generate_types(isa_args: &IsaArgs) -> Result<Vec<TokenStream>, anyhow::Error> {
    let types = isa_args
        .types
        .iter()
        .map(|ty| {
            let ident = Ident::new(&ty.pascal_case_name(), Span::call_site());
            let tokens = match &ty.r#type {
                TypeKind::Struct(members) => generate_struct(members, isa_args, ident)?,
                TypeKind::Enum(values) => generate_enum(values, ident),
            };
            Ok(tokens)
        })
        .collect::<Result<Vec<_>>>()?;
    Ok(types)
}

fn generate_arg_types(isa_args: &IsaArgs) -> Result<Vec<TokenStream>, anyhow::Error> {
    let arg_types = isa_args
        .args
        .iter()
        .map(|arg| {
            let ident = Ident::new(&arg.pascal_case_name(), Span::call_site());

            let tokens = match &arg.r#type {
                ArgType::Struct(members) => generate_struct(members, isa_args, ident)?,
                ArgType::Enum(values) => generate_enum(values, ident),
                ArgType::U32 => quote! {},
                ArgType::I32 => quote! {},
                ArgType::Bool => quote! {},
                ArgType::Custom(_) => quote! {},
            };
            Ok(tokens)
        })
        .collect::<Result<Vec<_>>>()?;
    Ok(arg_types)
}

fn generate_args_enum(isa_args: &IsaArgs, max_args: usize) -> Result<TokenStream, anyhow::Error> {
    let args_variants = isa_args
        .args
        .iter()
        .map(|arg| {
            let doc = format!(" {}", arg.desc);
            let variant = Ident::new(&arg.pascal_case_name(), Span::call_site());
            let variant_type = match &arg.r#type {
                ArgType::Struct(_) => quote! { #variant },
                ArgType::Enum(_) => quote! { #variant },
                ArgType::U32 => quote! { u32 },
                ArgType::I32 => quote! { i32 },
                ArgType::Bool => quote! { bool },
                ArgType::Custom(custom) => {
                    let custom_type = isa_args.get_type(custom)?;
                    let custom_name = custom_type.pascal_case_name();
                    let ident = Ident::new(&custom_name, Span::call_site());
                    quote! { #ident }
                }
            };

            Ok(quote! {
                #[doc = #doc]
                #variant(#variant_type)
            })
        })
        .collect::<Result<Vec<_>>>()?;
    let max_args = Literal::usize_suffixed(max_args);
    let args_enum = quote! {
        pub type Arguments = [Argument; #max_args];
        #[derive(Default, Clone, Copy, PartialEq, Eq, Debug)]
        pub enum Argument {
            #[default]
            None,
            #(#args_variants),*
        }
    };
    Ok(args_enum)
}

fn generate_enum(values: &[EnumValue], ident: Ident) -> TokenStream {
    let values_tokens = values
        .iter()
        .map(|value| {
            let doc = if let Some(desc) = &value.desc {
                let desc = format!(" {}", desc);
                quote! { #[doc = #desc] }
            } else {
                quote! {}
            };
            let variant = Ident::new(&value.pascal_case_name(), Span::call_site());
            let variant_value = Literal::u32_unsuffixed(value.value);
            quote! {
                #doc
                #variant = #variant_value
            }
        })
        .collect::<Vec<_>>();

    let parse_body = if is_continuous(values) {
        let min = values.iter().map(|v| v.value).min().unwrap_or(0);
        let max = values.iter().map(|v| v.value).max().unwrap_or(0);

        let max = Literal::u32_unsuffixed(max);
        let cond = if min == 0 {
            quote! { value <= #max }
        } else {
            let min = Literal::u32_unsuffixed(min);
            quote! { #min <= value && value <= #max }
        };

        quote! {
            if #cond {
                unsafe { std::mem::transmute::<u8, Self>(value as u8) }
            } else {
                Self::Illegal
            }
        }
    } else {
        let arms = values.iter().map(|value| {
            let value_lit = Literal::u32_unsuffixed(value.value);
            let variant = Ident::new(&value.pascal_case_name(), Span::call_site());
            quote! { #value_lit => Self::#variant }
        });
        quote! {
            match value {
                #(#arms),*
                _ => Self::Illegal,
            }
        }
    };

    quote! {
        #[derive(Default, Clone, Copy, PartialEq, Eq, Debug)]
        #[repr(u8)]
        pub enum #ident {
            #[default]
            Illegal = u8::MAX,
            #(#values_tokens),*
        }
        impl #ident {
            pub fn parse(value: u32) -> Self {
                #parse_body
            }
        }
    }
}

fn generate_struct(
    members: &BTreeMap<String, StructMember>,
    isa_args: &IsaArgs,
    ident: Ident,
) -> Result<TokenStream, anyhow::Error> {
    let members = members
        .iter()
        .map(|(name, member_type)| {
            let doc = format!(" {}", member_type.desc);
            let member = Ident::new(name, Span::call_site());
            let member_type = match &member_type.r#type {
                ArgType::Struct(_) => quote! { #member },
                ArgType::Enum(_) => quote! { #member },
                ArgType::U32 => quote! { u32 },
                ArgType::I32 => quote! { i32 },
                ArgType::Bool => quote! { bool },
                ArgType::Custom(custom) => {
                    let custom_type = isa_args.get_type(custom)?;
                    let custom_name = custom_type.pascal_case_name();
                    let ident = Ident::new(&custom_name, Span::call_site());
                    quote! { #ident }
                }
            };
            Ok(quote! {
                #[doc = #doc]
                pub #member: #member_type
            })
        })
        .collect::<Result<Vec<_>>>()?;
    Ok(quote! {
        #[derive(Default, Clone, Copy, PartialEq, Eq, Debug)]
        pub struct #ident {
            #(#members),*
        }
    })
}
